---
title: "Figures for Main text"
author: "zhiyi"
format:
  html:
    toc: true
    toc-location: right
    code-fold: true
    embed-resources: true
    number-sections: true
editor: source
---



```{r}
#| label: load_data
#| message: false
#| warning: false

#-----------------------1: set road
# input directory, absolute road
dir_input <- "/sdc/CAMS/COVID-Fire"
# output for data, absolute road
dir_data <- "/sdc/CAMS/COVID-Fire/data_quarto_store"
# output for figures, relative road
dir_figs <- "main-text"


#-----------------------2: load packages
library(magrittr)
library(data.table)
library(sf)
library(spData)
library(terra)
library(tidyterra)
library(ggplot2)
library(patchwork)
library(classInt)
library(fixest)
library(lubridate)


#-----------------------3: parameters
# parameters in mm
con_axis_text = 3
con_axis_title = 3
con_plot_title = 3
con_axis_line = 0.5
# Original pixel size is 463^2 m2, transform in ha
size_BA = base::round(463.31271653^2/10000, digits = 2)


#-----------------------4: frequently used data
##---------------4.1 weekly panel at 0.5°
# the balance panel spans all 52 weeks from 2016-2020
panel_balance <- fread(
  file.path(dir_input, "data_panel/panel_pt5_0924.csv")
)

# the unbalance panel only keep observation in first 26 weeks and before lockdown.
# Note that here we only keep grids that experienced lockdown, remove
# those without matched policy or mobility indexes and those matched but not
# experienced lockdown.
panel_unbalance <- panel_balance %>%
  # NA in original break_group were read as "" here.
  .[break_group %in% c("unlock", "lock-mobility", "lock-policy", "lock-both")] %>%
  .[break_group != "unlock"] %>%
  .[(week <= 26)&(week <= cp_2)]


##---------------4.2 frequently used data
# world map without Antarctica
world_rel <- world[world$name_long != "Antarctica", ]
# combine geometries to derive the vector boundary of the world
world_boundary <- st_union(world_rel)

# global grid template with 0.5 degree
rast_tmpl <- rast(
  nrows = 360, ncols = 720, nlyrs = 1,
  xmin = -180, xmax = 180, ymin = -90, ymax = 90,
  crs = "EPSG:4326"
)

# map by oxford division
map_oxford <- st_read(
  file.path(dir_input, "data_process/Map/map_oxford.gpkg"),
  quiet = TRUE
)
```



# Figure 1


## A-C - Temporal series

火点, 过火面积, 碳排放量我们直接全球取加和值. 然后计算3周平均值.
对于每一个周次, 由于是前后三个数值计算出来的均值, 除以sqrt(3)即可粗略视作标准误了.
唯一比较麻烦的点在于, 部分地区的封锁时间过早, 封锁前的当年凑不出-10周左右的观测, 得从前一年补.

对于16-19年, 我们先在格网上计算平均值, 再全球加和.


```{r}
#| label: fig1-temporal

#-----------------------单位换算
# emission_cfire, 数据源的原始单位: kg m-2 s-1, 转换成了数据框中的单位 μg m-2 s-1
# intg_area, 当前的单位: 10^4 m2
# 一周对应时间是7*24*60*60 = 604800 s
# 我们现在把排放通量转换成TgC(10^12 g), 所以需要将原始通量单位乘上面积和时间,
# 并进行单位换算.
# μg m-2 s-1 --- TgC (weekly)
# *604800*10^4_intg_area/(10^6*10^12)
#---|


#-----------------------lockdown time for each grid
#break_integration <- readRDS(
#  file.path(dir_input, "data_quarto_store/break_integration_pt5.rds")
#) %>%
#  .[, .(id, cp_1, cp_2, break_group)] %>%
#  .[,
#    `:=`(
#      id = as.integer(id),
#      cp_1 = as.integer(cp_1),
#      cp_2 = as.integer(cp_2)
#    )
#  ]
#break_integration[, summary(cp_1)]
# Min. 1st Qu.  Median    Mean 3rd Qu.    Max.    NA's 
# 3.00   11.00   12.00   11.02   12.00   19.00    2944
# 一半以上的格网, 封锁前的周次只有12周不到
#---|

# 以2020年为例, 计算2019年的周次相较于2020年封锁周次的相对周数
# week - (52 + cp_1)


#-----------------------1: 为每个格网制作序列
# 截取上一年相较于今年的封锁周次
extend_line <- panel_balance %>%
  .[break_group %in% c("lock-mobility", "lock-policy", "lock-both")] %>%
  # adjust 2019 for 2020
  .[year == 2019,
    `:=`(
      ext_year = 2020,
      ext_week = week - (52 + cp_1)
    )
  ] %>%
  # adjust 2018 for 2019
  .[year == 2018,
    `:=`(
      ext_year = 2019,
      ext_week = week - (52 + cp_1)
    )
  ] %>%
  # adjust 2017 for 2018
  .[year == 2017,
    `:=`(
      ext_year = 2018,
      ext_week = week - (52 + cp_1)
    )
  ] %>%
  # adjust 2016 for 2017
  .[year == 2016,
    `:=`(
      ext_year = 2017,
      ext_week = week - (52 + cp_1)
    )
  ] %>%
  .[ext_year %in% 2017:2020] %>%
  .[,
    year_group := cut(
      ext_year,
      breaks = c(2016, 2019, 2020),
      include.lowest = TRUE,
      labels = c("Y_1619", "Y_2020")
    ) %>% as.character()
  ] %>%
  .[,
    .(
      actfire_sum = mean(actfire_sum),
      BA_sum = mean(BA_sum),
      emission_cfire = mean(emission_cfire),
      
      intg_area = mean(intg_area)
    ),
    by = c("id", "year_group", "ext_week")
  ] %>%
  setnames(
    # change the name for the following alignment
    old = "ext_week", new = "week_to_treated"
  )

# 计算本年度内的相对封锁周次
nature_line <- panel_balance %>%
  .[break_group %in% c("lock-mobility", "lock-policy", "lock-both")] %>%
  .[,
    year_group := cut(
      year,
      breaks = c(2016, 2019, 2020),
      include.lowest = TRUE,
      labels = c("Y_1619", "Y_2020")
    ) %>% as.character()
  ] %>%
  .[,
    .(
      actfire_sum = mean(actfire_sum),
      BA_sum = mean(BA_sum),
      emission_cfire = mean(emission_cfire),
      
      intg_area = mean(intg_area)
    ),
    by = c("id", "year_group", "week_to_treated")
  ]

# 为每个格网合并当年及去年计算下来的相对周次信息
join_line <- rbindlist(
  list(extend_line, nature_line)
  ) %>%
  .[order(id, year_group, week_to_treated)] %>%
  # 只保留前后各自22周
  .[week_to_treated %in% seq(-22, 22)]

#join_line[, .N/length(unique(id))]
# 90; 每个格网对应45*2=90周的观测

#join_line[
#  ,
#  .(count = .N),
#  by = c("id", "week_to_treated")
#  ] %>%
#  .[, unique(count)]
# 2; 每个格网的每个相对周次都对应着两个年份组,没有问题.



#-----------------------2: 全球加和
# 1) 全球加和
# 2) 3周移动平均, 同时计算标准误(标准差除以根号3)

# 因为后续要3周滑动平均, 这里我们用-1及前后两周加和的均值作为基准值
ref_week <- join_line %>%
  .[week_to_treated %in% c(-2, -1, 0)] %>%
  .[,
    .(
      actfire_sum = sum(actfire_sum)/10^4,                       # unit: 10^4
      BA_sum = sum(BA_sum)*size_BA/10^4,                         # unit: 10^4 ha
      emission_cfire = sum(emission_cfire*intg_area*10^4*604800)/10^18     # TgC(weekly)
    )
    ,
    by = c("year_group", "week_to_treated")
  ] %>%
  .[,
    .(
      base_actfire = mean(actfire_sum),
      base_BA = mean(BA_sum),
      base_emission = mean(emission_cfire)
    ),
    by = "year_group"
  ]

glob_line <- join_line %>%
  .[,
    .(
      actfire_sum = sum(actfire_sum)/10^4,                       # unit: 10^4
      BA_sum = sum(BA_sum)*size_BA/10^4,                        # unit: 10^4 ha
      emission_cfire = sum(emission_cfire*intg_area*10^4*604800)/10^18      # TgC(weekly)
    )
    ,
    by = c("year_group", "week_to_treated")
  ] %>%
  merge(
    ref_week,
    by = "year_group",
    all.x = TRUE, sort = FALSE
  ) %>%
  .[,
    `:=`(
      norm_actfire = actfire_sum / base_actfire,
      norm_BA = BA_sum / base_BA,
      norm_emission = emission_cfire / base_emission
    )
  ] %>%
  .[order(year_group, week_to_treated)] %>%
  .[,
    `:=`(
      mov_actfire = frollapply(
        x = norm_actfire,
        n = 3,
        FUN = mean,
        align = "center"
      ),
      mov_BA = frollapply(
        x = norm_BA,
        n = 3,
        FUN = mean,
        align = "center"
      ),
      mov_emission = frollapply(
        x = norm_emission,
        n = 3,
        FUN = mean,
        align = "center"
      ),
      
      se_actfire = frollapply(
        x = norm_actfire,
        n = 3,
        FUN = sd,
        align = "center"
      ) / sqrt(3),
      se_BA = frollapply(
        x = norm_BA,
        n = 3,
        FUN = sd,
        align = "center"
      ) / sqrt(3),
      se_emission = frollapply(
        x = norm_emission,
        n = 3,
        FUN = sd,
        align = "center"
      ) / sqrt(3)
    ),
    
    by = "year_group"
  ]



#-----------------------3: 绘图
##---------------3.1 fig1_a
ggplot(glob_line) +
  geom_vline(
    xintercept = -1, linetype = "dashed", color = "grey80"
  ) +
  geom_hline(
    yintercept = 1, linetype = "dashed", color = "grey80"
  ) +
  geom_ribbon(
    aes(
      x = week_to_treated,
      ymin = mov_actfire - se_actfire,
      ymax = mov_actfire + se_actfire,
      fill = year_group
    ),
    alpha = 0.2
  ) +
  geom_line(
    aes(x = week_to_treated, y = mov_actfire, color = year_group)
  ) +
  geom_point(
    aes(x = week_to_treated, y = mov_actfire, color = year_group),
    size = 0.6
  ) +
  scale_color_manual(
    limits = c("Y_1619", "Y_2020"),
    labels = c("2016-2019", "2020"),
    values = c("grey50", "#E41A1C"),
    name = NULL
  ) +
  scale_fill_manual(
    limits = c("Y_1619", "Y_2020"),
    labels = c("2016-2019", "2020"),
    values = c("grey50", "indianred1"),
    name = NULL
  ) +
  scale_x_continuous(
    limits = c(-6, 16)
  ) +
  scale_y_continuous(
    limits = c(0.7, 2),
    breaks = seq(0.8, 1.4, 0.2)
  ) +
  coord_cartesian(
    xlim = c(-5.5, 15.5),
    ylim = c(0.7, 1.6),
    expand = FALSE
  ) +
  theme(
    panel.background = element_rect(fill = "white"),
    panel.grid = element_line(),
    panel.border = element_rect(
      fill = NA, color = "black", , linewidth = 0.2
    ),
    
    legend.position = "inside",
    legend.position.inside = c(0, 1),
    legend.justification.inside = c(0, 1),
    legend.background = element_rect(fill = NA),
    
    axis.title = element_text(size = con_axis_title*.pt*0.9),
    axis.text = element_text(size = con_axis_text*.pt*0.9),
    legend.text = element_text(size = con_axis_text*.pt*0.9),
    legend.key.size = unit(con_axis_text*1.2, "mm"),
    plot.title.position = "plot",
    plot.title = element_text(size = con_axis_title*.pt, face = "bold")
  ) +
  labs(
    x = "Weeks since mobility restriction",
    y = "Normalized active fire",
    title = "A"
  )

#ggsave(
#  file.path(dir_figs, "fig1_a.pdf"),
#  width = 60, height = 50, units = "mm"
#)


##---------------3.2 fig1_b
ggplot(glob_line) +
  geom_vline(
    xintercept = -1, linetype = "dashed", color = "grey80"
  ) +
  geom_hline(
    yintercept = 1, linetype = "dashed", color = "grey80"
  ) +
  geom_ribbon(
    aes(
      x = week_to_treated,
      ymin = mov_BA - se_BA,
      ymax = mov_BA + se_BA,
      fill = year_group
    ),
    alpha = 0.2
  ) +
  geom_line(
    aes(x = week_to_treated, y = mov_BA, color = year_group)
  ) +
  geom_point(
    aes(x = week_to_treated, y = mov_BA, color = year_group),
    size = 0.6
  ) +
  scale_color_manual(
    limits = c("Y_1619", "Y_2020"),
    labels = c("2016-2019", "2020"),
    values = c("grey50", "#E41A1C"),
    name = NULL
  ) +
  scale_fill_manual(
    limits = c("Y_1619", "Y_2020"),
    labels = c("2016-2019", "2020"),
    values = c("grey50", "indianred1"),
    name = NULL
  ) +
  scale_x_continuous(
    limits = c(-6, 16)
  ) +
  scale_y_continuous(
    limits = c(0.7, 3.5),
    breaks = seq(1, 3, 0.5)
  ) +
  coord_cartesian(
    xlim = c(-5.5, 15.5),
    ylim = c(0.7, 2.9),
    expand = FALSE
  ) +
  theme(
    panel.background = element_rect(fill = "white"),
    panel.grid = element_line(),
    panel.border = element_rect(
      fill = NA, color = "black", , linewidth = 0.2
    ),
    
    legend.position = "none",
    
    axis.title = element_text(size = con_axis_title*.pt*0.9),
    axis.text = element_text(size = con_axis_text*.pt*0.9),
    plot.title.position = "plot",
    plot.title = element_text(size = con_axis_title*.pt, face = "bold")
  ) +
  labs(
    x = "Weeks since mobility restriction",
    y = "Normalized burned area",
    title = "B"
  )

#ggsave(
#  file.path(dir_figs, "fig1_b.pdf"),
#  width = 60, height = 50, units = "mm"
#)


##---------------3.2 fig1_c
ggplot(glob_line) +
  geom_vline(
    xintercept = -1, linetype = "dashed", color = "grey80"
  ) +
  geom_hline(
    yintercept = 1, linetype = "dashed", color = "grey80"
  ) +
  geom_ribbon(
    aes(
      x = week_to_treated,
      ymin = mov_emission - se_emission,
      ymax = mov_emission + se_emission,
      fill = year_group
    ),
    alpha = 0.2
  ) +
  geom_line(
    aes(x = week_to_treated, y = mov_emission, color = year_group)
  ) +
  geom_point(
    aes(x = week_to_treated, y = mov_emission, color = year_group),
    size = 0.6
  ) +
  scale_color_manual(
    limits = c("Y_1619", "Y_2020"),
    labels = c("2016-2019", "2020"),
    values = c("grey50", "#E41A1C"),
    name = NULL
  ) +
  scale_fill_manual(
    limits = c("Y_1619", "Y_2020"),
    labels = c("2016-2019", "2020"),
    values = c("grey50", "indianred1"),
    name = NULL
  ) +
  scale_x_continuous(
    limits = c(-6, 16)
  ) +
  scale_y_continuous(
    limits = c(0.5, 2), expand = expansion(add = 0),
    breaks = seq(0.6, 1.8, 0.4)
  ) +
  coord_cartesian(
    xlim = c(-5.5, 15.5),
    ylim = c(0.5, 1.9),
    expand = FALSE
  ) +
  theme(
    panel.background = element_rect(fill = "white"),
    panel.grid = element_line(),
    panel.border = element_rect(
      fill = NA, color = "black", , linewidth = 0.2
    ),
    
    legend.position = "none",
    
    axis.title = element_text(size = con_axis_title*.pt*0.9),
    axis.text = element_text(size = con_axis_text*.pt*0.9),
    plot.title.position = "plot",
    plot.title = element_text(size = con_axis_title*.pt, face = "bold")
  ) +
  labs(
    x = "Weeks since mobility restriction",
    y = "Normalized carbon emission",
    title = "C"
  )

#ggsave(
#  file.path(dir_figs, "fig1_c.pdf"),
#  width = 60, height = 50, units = "mm"
#)

```


## D - Spatial


```{r}
#| label: fig1-spatial

#-----------------------1: data
spatdt_rel <- panel_balance %>%
  .[break_group %in% c("lock-mobility", "lock-policy", "lock-both")] %>%
  # the first two months after lockdown
  .[week_to_treated %in% 0:8] %>%
  .[,
    year_group := cut(
      year,
      breaks = c(2016, 2019, 2020),
      include.lowest = TRUE,
      labels = c("Y_1619", "Y_2020")
    )
  ] %>%
  .[,
    .(actfire_sum = mean(actfire_sum)),
    by = c("id", "year_group", "week_to_treated")
  ] %>%
  dcast(
    id + week_to_treated ~ year_group,
    value.var = "actfire_sum"
  ) %>%
  .[order(id, week_to_treated)] %>%
  # difference values for the following t.test
  .[, diff_actfire := Y_2020 - Y_1619] %>%
  .[,
    .(
      mean_1619 = mean(Y_1619),
      mean_2020 = mean(Y_2020),
      
      estimate_actfire = t.test(diff_actfire)[["estimate"]],
      pvalue_actfire = t.test(diff_actfire)[["p.value"]]
    ),
    by = "id"
  ] %>%
  .[,
    per_actfire := (mean_2020 - mean_1619)/mean_1619*100
  ] %>%
  merge(                                                # 获取0.5°格网的中心坐标
    data.table(
      id = values(terra::init(rast_tmpl, fun = "cell"))[, 1],
      x = values(terra::init(rast_tmpl, fun = "x"))[, 1],
      y = values(terra::init(rast_tmpl, fun = "y"))[, 1]
    ),
    by = "id",
    all = FALSE,
    sort = FALSE
  )

spatdt_rel[pvalue_actfire < 0.05, .N]/nrow(spatdt_rel)                    # 0.09
spatdt_rel[, quantile(estimate_actfire, probs = seq(0, 1, 0.1))]


dt_point <- spatdt_rel %>%
  .[pvalue_actfire < 0.05] %>%
  .[,
    `:=`(
      end_x = (x - floor(x)) * 100,
      end_y = (y - floor(y)) * 100
    )
  ] %>%
  # 筛选下格网
  .[end_x == 25] %>%
  .[end_y == 75]



#-----------------------2: plot
rast_per_actfire <- rast_tmpl
rast_per_actfire[spatdt_rel[, id]] <- spatdt_rel[, per_actfire]

ggplot() +
  geom_sf(
    data = world_rel, fill = "white",
    color = NA
  ) +
  geom_spatraster(
    data = rast_per_actfire, maxcell = 360*720
  ) +
  # boundary line within the continent
  geom_sf(
    data = world_rel, fill = NA,
    color = "grey",  linewidth = 0.15
  ) +
  # linewidth must be wider so that to complete mask the previous land boundary
  geom_sf(
    data = world_boundary, fill = NA,
    color = "white", linewidth = 0.2
  ) +
  scale_fill_distiller(
    palette = "RdBu",
    limits = c(-100, 100), oob = scales::squish,
    breaks = seq(-80, 80, 20), na.value = NA,
    
    guide = guide_colorbar(
      title = "Changes in active fires during the first two months since mobility restriction (%)",
      direction = "horizontal",
      frame.color = "black",
      frame.linewidth = con_axis_line*0.3,
      barwidth = grid::unit(0.93, "npc"),
      barheight = grid::unit(3, "mm")
    )
  ) +
  scale_x_continuous(
    expand = expansion(add = 0)
  ) +
  scale_y_continuous(
    limits = c(-57, 83),
    expand = expansion(add = 0)
  ) +
  theme(
    panel.background = element_rect(fill = "#C3E8F9"),
    panel.border = element_rect(fill = NA, color = "black", linewidth = 0.2),
    panel.grid = element_blank(),
    
    legend.position = "bottom",
    legend.title.position = "bottom",
    legend.title = element_text(
      size = con_axis_title*.pt, hjust = 0.5,
      margin = margin(t = 0, unit = "pt")
    ),
    legend.text = element_text(size = con_axis_text*.pt),
    legend.ticks = element_line(color = "black", linewidth = con_axis_line*0.3),
    legend.margin = margin(t = -5, b = 0, unit = "pt"),
    
    plot.title = element_text(size = con_axis_title*.pt, face = "bold"),
    plot.title.position = "plot",
    axis.text = element_text(size = con_axis_text*.pt)
  ) +
  labs(
    x = NULL, y = NULL,
    title = "D"
  )

#ggsave(
#  file.path(dir_figs, "fig1_d.pdf"),
#  width = 180, height = 95, units = "mm"
#)
```



# Figure 2


## Overall effect


```{r}
#| label: fixed_overall

yvar_fire = "actfire_sum"
yvar_BA = "BA_sum"
xvar = "shutdown_2020"
controls = "+ weather_tempe + weather_tempe_square + weather_winds + weather_preci + weather_RH + weather_VPD"
#fe = "id + year + intg_oxfordID^intg_biome^week"
fe = "intg_oxfordID^intg_biome^week + intg_oxfordID^intg_biome^year"
vvar = "~intg_oxfordID^intg_biome"        # poisson残差不能用"iid", 否则异常显著

fmla_fixed_fire <- as.formula(
  paste(yvar_fire, "~", xvar, controls, "|", fe)
)
fmla_fixed_BA <- as.formula(
  paste(yvar_BA, "~", xvar, controls, "|", fe)
)



model_fixed_glb_fire <- feglm(
  fmla_fixed_fire,
  panel_unbalance,
  family = "poisson",
  vcov = as.formula(vvar)
)

model_fixed_glb_BA <- feglm(
  fmla_fixed_BA,
  panel_unbalance,
  family = "poisson",
  vcov = as.formula(vvar)
)

```





## A - Local Regression

以0.5°格网为支撑, 在4°范围内进行区域建模, 得到局部变化系数.


```{r}
#| label: local_regression

#-----------------------1: 读取格网数据
# global grid template with 0.5 degree
rast_tmpl_pt5 <- rast(
  nrows = 360, ncols = 720, nlyrs = 1,
  xmin = -180, xmax = 180, ymin = -90, ymax = 90,
  crs = "EPSG:4326"
)
# global grid template with 4 degree
rast_tmpl_4 <- rast(
  nrows = 45, ncols = 90, nlyrs = 1,
  xmin = -180, xmax = 180, ymin = -90, ymax = 90,
  crs = "EPSG:4326"
)



#-----------------------2: 制作新型面板
##---------------2.1 提取0.5°格网所对应的4°编号
# 获得每个4°格网的编号
rast_cell_4 <- terra::init(rast_tmpl_4, fun = "cell")
rast_cell_4
# dimensions  : 45, 90, 1  (nrow, ncol, nlyr)
# resolution  : 4, 4  (x, y)
# extent      : -180, 180, -90, 90  (xmin, xmax, ymin, ymax)
# coord. ref. : lon/lat WGS 84 (EPSG:4326)

# 提取全球0.5°格网中心点的横纵坐标
grid_bridge <- data.table(
  id = values(terra::init(rast_tmpl_pt5, fun = "cell"))[, 1],
  x = values(terra::init(rast_tmpl_pt5, fun = "x"))[, 1],
  y = values(terra::init(rast_tmpl_pt5, fun = "y"))[, 1]
)
# 提取每个0.5°格网中心点所对应的4°格网编号
vec_ID4 <- terra::extract(
  x = rast_cell_4,
  y = grid_bridge[, .(x, y)],
  ID = FALSE
) %>%
  dplyr::pull(1)
grid_bridge[, ID4 := vec_ID4] %>%
  .[, c("x", "y") := NULL]
# "id" :  0.5°格网编号
# "ID4":  4°格网编号


##---------------2.2 整合面板
# 我们尝试不基于火点/过火面积数目再做筛选
panel_local <- panel_unbalance %>%
  # 剔除未匹配上气象变量的观测, 不然会干扰建模.
  .[!is.na(weather_tempe)] %>%
  # 关联4°格网编号
  merge(
    grid_bridge,
    by = "id",
    all = FALSE,
    sort = FALSE
  )



#-----------------------3: 格网统计
# 统计每个4°格网内的火点数目和过火面积大小
# 统计每个4°格网内的子格网数目, 并只保留至少含10个子格网的IDpt5
grid_count <- panel_local %>%
  .[,
    .(
      sum_actfire_id = sum(actfire_sum),
      sum_BA_id = sum(BA_sum)
    ),
    by = c("ID4", "id")
  ] %>%
  .[,
    .(
      sum_actfire = sum(sum_actfire_id),
      sum_BA = sum(sum_BA_id),
      
      number_id = .N
    ),
    by = "ID4"
  ]
grid_count[, .N]
# 原本有1154个4°格网
grid_count[(sum_actfire > 0)&(number_id >= 10), .N]
# 研究时段内曾检测到火点且包含至少十个0.5°子格网的4°格网, 共有896个
grid_count[(sum_BA > 0)&(number_id >= 10), .N]
# 研究时段内曾检测到过火面积且包含至少十个0.5°子格网的4°格网, 共有817个



#-----------------------4: 0.5°格网内的火点建模
# 这里我们利用DiD框架提取封锁效应,
# 如果觉得week添加了过多的协变量, 后续可能改成shutdown + shutdown_2020的方式.
# 由于我们是在0.5°格网内部建模, 只需要添加week和year固定效应,
# 固定效应在这里就是默认包含在内的截距项了.

##---------------4.1 系数提取
func_local <- function(
  rawdata,
  yvar = "actfire_sum",
  xvar = "shutdown_2020",
  controls = "+ weather_tempe + weather_tempe_square + weather_winds + weather_preci + weather_RH + weather_VPD",
  #fe = "week + year",
  #vvar = "iid",
  fe_complete = "intg_oxfordID^intg_biome^week + intg_oxfordID^intg_biome^year",
  vvar_complete = "intg_oxfordID^intg_biome",
  fe_simple = "week + year",
  vvar_simple = "iid",
  iter_thre = 1000
  ){
  
  #fmla_local <- as.formula(
  #  paste(yvar, "~", xvar, controls, "|", fe)
  #)
  #model_local <- feglm(
  #  fml = fmla_local,
  #  data = rawdata,
  #  family = "poisson",
  #  vcov = vvar,
  #  glm.iter = iter_thre
  #)
  
  model_try <- try(
    feglm(
      fml = as.formula(paste(yvar, "~", xvar, controls, "|", fe_complete)),
      data = rawdata,
      family = "poisson",
      vcov = as.formula(paste0("~", vvar_complete)),
      glm.iter = iter_thre
    )
  )
  if("try-error" %in% class(model_try)){
    model_local <- feglm(
      fml = as.formula(paste(yvar, "~", xvar, controls, "|", fe_simple)),
      data = rawdata,
      family = "poisson",
      vcov = vvar_simple,
      glm.iter = iter_thre
    )
  } else{
    model_local <- feglm(
      fml = as.formula(paste(yvar, "~", xvar, controls, "|", fe_complete)),
      data = rawdata,
      family = "poisson",
      vcov = as.formula(paste0("~", vvar_complete)),
      glm.iter = iter_thre
    )
  }
  
  coef_name <- names(coef(model_local))
  # Only keep the regression result where shutdown_2020 has not been removed
  # because of co-linearity.
  if("shutdown_2020" %in% coef_name){
    
    dt_local <- data.table(
      # the coefficent has been transofrmed as exponentiated coefficients minus 1
      coef = coeftable(model_local)["shutdown_2020", "Estimate"] %>% exp() - 1,
      p_value = coeftable(model_local)["shutdown_2020", "Pr(>|z|)"],
      iteration = model_local$iterations
    )
    
    return(dt_local)
  }
}

tt <- Sys.time()
local_fixed_actfire <- panel_local %>%
  # 筛选包含了一定数目子格网的4°格网
  .[ID4 %in% grid_count[(sum_actfire > 0)&(number_id >= 10), ID4]] %>%
  # 分组回归
  .[,
    func_local(.SD),
    by = "ID4"
  ]
print(Sys.time() - tt)
# 2.681738 mins; 看来1000这个设定让迭代变久了.

# 由于固定效应设定, 许多组内都会由于固定效应周次内没有观测到火点而将对应观测移除.
# 在一些区域范围内, shutdown_2020由于共线性原因会被剔除掉, 以下是其警告信息:
# The variable 'shutdown_2020' has been removed because of collinearity (see $collin.var).
# 此外, 一些组即使迭代到1000也没有收敛, 出现以下警告信息:
# Warning: Absence of convergence: Maximum number of iterations reached (1000).
#          Final deviance: 289.0.
# 应当就是达到最大迭代次数之后(这里将glm.iter设定为1000), 仍然没收敛到glm.tol
# 因此这里我们提取每次local regression所得到的迭代次数. 如果等于1000(glm.iter),
# 说明迭代到最大上限也没收敛到阈值之内, 我们就可以将这个local regression结果剔除在外.
local_fixed_actfire[, .N]
# 4°格网数目从896个减少到795个了.
local_fixed_actfire[iteration == 1000, .N]
# 6个4°区域没有收敛.


##---------------4.2 制作绘图数据
# 获得4°格网在2016-2019年平行封锁期间的火点数目, 用于展示圆圈大小.
fire_median <- panel_local %>%
  .[ID4 %in% grid_count[(sum_actfire > 0)&(number_id >= 10), ID4]] %>%
  .[(year %in% 2016:2019) & (shutdown == 1)] %>%
  .[,
    .(fire_year = sum(actfire_sum)),
    by = c("ID4", "year")
  ] %>%
  .[,
    .(fire_median = median(fire_year)),
    by = "ID4"
  ] %>%
  .[fire_median > 1]                             # 筛选基准火点数目大于1的4°格网

dt_coef <- local_fixed_actfire %>%
  .[iteration < 1000] %>%
  .[(coef > 0)&(p_value <  0.05), c("group_chr", "group_int") := .("pos-sig", 1L)] %>%
  .[(coef > 0)&(p_value >= 0.05), c("group_chr", "group_int") := .("pos-non", 2L)] %>%
  .[(coef < 0)&(p_value >= 0.05), c("group_chr", "group_int") := .("neg-non", 3L)] %>%
  .[(coef < 0)&(p_value <  0.05), c("group_chr", "group_int") := .("neg-sig", 4L)] %>%
  # 关联4°格网的中心坐标
  merge(
    data.table(
      ID4 = values(terra::init(rast_tmpl_4, fun = "cell"))[, 1],
      x = values(terra::init(rast_tmpl_4, fun = "x"))[, 1],
      y = values(terra::init(rast_tmpl_4, fun = "y"))[, 1]
    ),
    by = "ID4",
    all = FALSE, sort = FALSE
  ) %>%
  # 关联4°格网的基准火点数目
  merge(
    fire_median,
    by = "ID4",
    all = FALSE,
    sort = FALSE
  )

dt_coef[group_chr %in% c("pos-sig", "neg-sig"), .N]/dt_coef[, .N]
# 有57.03%的格网火点在封锁时段内出现了显著变化(这么高?)
dt_coef[group_chr == "pos-sig", .N]/dt_coef[group_chr %in% c("pos-sig", "neg-sig"), .N]
# 在显著变化的格网中, 有51.33%的格网火点出现了增加
dt_coef[group_chr == "neg-sig", .N]/dt_coef[group_chr %in% c("pos-sig", "neg-sig"), .N]
# 在显著变化的格网中, 有48.67%的格网火点出现了减少


##---------------4.3 绘图
###-----4.3.1 main plot
# present fire basis number by circle size
dt_coef[, quantile(fire_median, probs = seq(0, 1, 0.1))]
#   0%    10%    20%     30%     40%     50%     60%      70%      80%      90%       100% 
# 2.00  29.50  79.40  174.50  300.10  475.25  838.60  1644.35  2811.50  6649.35  123400.00

# Since we maily present significant coefficients here, we should focus on
# fire number of grid whose fire experienced significant changes.
dt_coef[group_chr == "neg-sig", quantile(fire_median, probs = seq(0, 1, 0.1))]
#  0%   10%    20%    30%    40%    50%     60%     70%     80%     90%     100%
# 2.5  41.9  120.1  221.5  337.5  588.5  1129.1  2065.4  3585.9  8863.3  123400.0
dt_coef[group_chr == "pos-sig", quantile(fire_median, probs = seq(0, 1, 0.1))]
#  0%   10%    20%    30%    40%    50%     60%     70%     80%     90%     100%
# 2.5  36.4   74.0  149.3  290.7  440.0   912.0  1660.3  2864.4  5897.1  51115.0

dt_coef[group_chr == "neg-sig", sum(fire_median)] / dt_coef[, sum(fire_median)] # 0.43
dt_coef[group_chr == "pos-sig", sum(fire_median)] / dt_coef[, sum(fire_median)] # 0.22
# The fire number that positively significant changed grids account for is much lower

ggplot(dt_coef) +
  geom_sf(
    data = world_rel, fill = "white",
    color = "grey",  linewidth = 0.15
  ) +
  # linewidth must be wider so that to complete mask the previous land boundary
  geom_sf(
    data = world_boundary, fill = NA,
    color = "white", linewidth = 0.2
  ) +
  # grids with insignificant coefficients
  geom_point(
    aes(
      x = x, y = y,
      size = pmax(pmin(fire_median, 10000), 100)
    ),
    data = dt_coef[p_value >= 0.05],
    shape = 21, color = "grey85", fill = "grey85", stroke = 0.2
  ) +
  # grids with significant coefficients
  geom_point(
    aes(
      x = x, y = y,
      fill = coef*100,                                              # percentage
      size = pmax(pmin(fire_median, 10000), 100)
    ),
    data = dt_coef[p_value < 0.05],
    shape = 21, color = "grey20", stroke = 0.2
  ) +
  scale_size(
    name = "Fire count",
    range = c(0.4, 2),
    trans = "log10",
    breaks = c(10^2, 10^3, 10^4),
    labels = expression(10^2, 10^3, 10^4),
    
    guide = guide_legend(
      override.aes = list(
        shape = 21, fill = NA,
        stroke = 0.2, color = "black"
      ),
      direction = "horizontal",
      theme = theme(
        legend.key = element_blank(),
        legend.background = element_blank(),
        legend.title.position = "left",
        legend.title = element_text(size = con_axis_title*.pt),
        legend.text = element_text(
          # narrow the distance between legend.key and legend.text
          margin = margin(l = 0, r = 0, unit = "mm"),
          size = con_axis_text*.pt
        ),
        legend.key.size = unit(4, "mm"),
        legend.key.spacing.x = unit(0.5, "mm")
      ),
      order = 0
    )
  ) +
  scale_fill_fermenter(
    name = "Relative changes (%)",
    palette = "RdBu",
    breaks = c(-80, -40, 0, 40, 80),
    labels = c(-80, -40, 0, 40, 80),
    
    guide = guide_colorsteps(
      theme = theme(
        legend.background = element_blank(),
        legend.frame = element_rect(fill = NA, color = "black", linewidth = 0.2),
        legend.direction = "horizontal",
        
        legend.title.position = "bottom",
        legend.title = element_text(
          margin = margin(t = 0.5, unit = "mm"),
          size = con_axis_title*.pt
        ),
        legend.text = element_text(
          margin = margin(t = 1, unit = "mm"),
          size = con_axis_text*.pt*0.8
        ),
        legend.key.width = unit(28, "mm"),
        legend.key.height = unit(4, "mm")
      ),
      order = 1
    )
  ) +
  scale_x_continuous(
    expand = expansion(add = 0)
  ) +
  scale_y_continuous(
    limits = c(-57, 83),
    expand = expansion(add = 0)
  ) +
  theme(
    panel.background = element_rect(fill = "#C3E8F9"),    # "#C3E8F9", "#CCE7F9"
    panel.border = element_rect(fill = NA, color = "black", linewidth = 0.2),
    panel.grid = element_blank(),
    
    legend.position = "inside",
    legend.position.inside = c(0, 0),
    legend.justification.inside = c(0, 0),
    legend.box = "vertical",
    
    plot.title = element_text(size = con_axis_title*.pt, face = "bold"),
    plot.title.position = "plot",
    axis.text = element_text(size = con_axis_text*.pt)
  ) +
  labs(
    x = NULL,
    y = "",                           # align with panel B, who has y axis title
    title = "A"
  )

#ggsave(
#  file.path(dir_figs, "Main-3_2_local_coef_circle_main.pdf"),
#  width = 180, height = 80, units = "mm", dpi = 300
#)

###-----4.3.2 minor plot
# RColorBrewer::display.brewer.all()
# RColorBrewer::brewer.pal(n = 6, name = "RdBu")
# "#B2182B" "#EF8A62" "#FDDBC7" "#D1E5F0" "#67A9CF" "#2166AC"

dt_coef_fraction <- dt_coef %>%
  copy() %>%
  .[, percentage := fire_median / sum(fire_median) * 100] %>%
  .[group_chr %in% c("pos-non", "neg-non"), label := "0"] %>%
  .[(group_chr == "neg-sig")&(coef < -0.8),
    c("label", "fill") := .("1", "#2166AC")
  ] %>%
  .[(group_chr == "neg-sig")&(coef >= -0.8)&(coef < -0.4),
    c("label", "fill") := .("2", "#67A9CF")
  ] %>%
  .[(group_chr == "neg-sig")&(coef >= -0.4),
    c("label", "fill") := .("3", "#D1E5F0")
  ] %>%
  .[(group_chr == "pos-sig")&(coef <= 0.4),
    c("label", "fill") := .("4", "#FDDBC7")
  ] %>%
  .[(group_chr == "pos-sig")&(coef > 0.4)&(coef <= 0.8),
    c("label", "fill") := .("5", "#EF8A62")
  ] %>%
  .[(group_chr == "pos-sig")&(coef > 0.8),
    c("label", "fill") := .("6", "#B2182B")
  ] %>%
  .[,
    .(fraction = sum(percentage)),
    by = c("label", "fill")
  ] %>%
  .[order(label)]

ggplot(dt_coef_fraction[label != "0"]) +
  geom_col(
    aes(
      x = label, y = fraction,
      fill = fill
    ),
    width = 1,
    color = "black", linewidth = con_axis_line*0.4
  ) +
  scale_fill_identity() +
  scale_x_discrete() +
  scale_y_continuous(
    expand = expansion(mult = c(0, 0.05))
  ) +
  theme(
    panel.background = element_blank(),
    plot.background = element_blank(),
    panel.grid = element_blank(),
    plot.margin = unit(
      c(0.2, 0.2, 0.2, 0.2), "mm"
    ),
    
    
    axis.text.x.bottom = element_blank(),
    axis.line.x.bottom = element_line(
      color = "black", linewidth = con_axis_line*0.4
    ),
    axis.ticks.x.bottom = element_blank(),
    axis.title.y.left = element_text(
      size = con_axis_text*.pt
    ),
    axis.text.y.left = element_text(
      size = con_axis_text*.pt
    ),
    axis.line.y.left = element_line(
      color = "black", linewidth = con_axis_line*0.4
    ),
    axis.ticks.y.left = element_line(
      color = "black", linewidth = con_axis_line*0.4
    ),
  ) +
  labs(
    x = NULL,
    y = "Fraction (%)"
  )

#ggsave(
#  file.path(dir_figs, "Main-3_2_local_coef_circle_minor.pdf"),
#  width = 35, height = 18, units = "mm"
#)
```


## B - Fixed effect in each country


```{r}
#| label: fixed_region

#-----------------------1: Formula
yvar = "actfire_sum"
xvar = "shutdown_2020"
vvar = "intg_oxfordID^intg_biome"
controls = "+ weather_tempe + weather_tempe_square + weather_winds + weather_preci + weather_RH + weather_VPD"
fe = "intg_oxfordID^intg_biome^week + intg_oxfordID^intg_biome^year"

fmla_fixed <- as.formula(
  paste(yvar, "~", xvar, controls, "|", fe)
)



#-----------------------2: Regression in each country
panel_unbalance[CountryName != "", length(unique(CountryName))]
# 总共有147个国家

##---------------2.1 group information
# 获得研究时段内各个国家的平均火点数目,
# 再用2016-2019年的中位数去代表国家基数水平.
fire_median <- panel_unbalance %>%
  .[CountryName != ""] %>%
  .[(year %in% 2016:2019) & (shutdown == 1)] %>%
  .[,
    .(fire_year = sum(actfire_sum)),
    by = c("CountryName", "CountryCode", "year", "Region")
  ] %>%
  .[,
    .(fire_median = median(fire_year)),
    by = c("CountryName", "CountryCode", "Region")
  ] %>%
  .[fire_median > 100]     # 是否合理呢? 我们只保留研究时段内100个火点以上的国家
# 应当算作合理, 因为我们一个4°格网圆圈大小的展示限制也是在100个火点以上.

table_CountryName <- data.table(
  group_var = "CountryName",
  group_num = 1:panel_unbalance[CountryName != "", length(unique(CountryName))],
  group_lab = panel_unbalance[CountryName != "", sort(unique(CountryName))]
  ) %>%
  # 添加系数用于后续填充, NaN是为了让变量类型为数值型.
  .[,
    c("coef", "CI_025", "CI_975", "p") := NaN
  ] %>%
  merge(
    fire_median,
    by.x = "group_lab",
    by.y = "CountryName",
    all = FALSE,
    sort = FALSE
  )


##---------------2.2 regression in order
for (ii in 1:nrow(table_CountryName)) {
  
  # 部分国家intg_oxfordID^intg_biome只有一种, 这时残差方式会报错,
  # 所以需要进行一次判定
  model_int <- try(
    feglm(
      fmla_fixed,
      panel_unbalance[
        get(table_CountryName[ii, group_var]) == table_CountryName[ii, group_lab]
      ],
      family = "poisson",
      vcov = as.formula(paste0("~", vvar))
    )
  )
  if("try-error" %in% class(model_int)){
    model_int <- feglm(
      fmla_fixed,
      panel_unbalance[
        get(table_CountryName[ii, group_var]) == table_CountryName[ii, group_lab]
      ],
      family = "poisson",
      vcov = "iid"
    )
  }
  
  
  if("shutdown_2020" %in% names(coef(model_int))){
    table_CountryName[ii, coef := coef(model_int)[["shutdown_2020"]] %>% exp() -1]
    table_CountryName[ii, CI_025 := confint(model_int)["shutdown_2020", "2.5 %"] %>% exp() -1]
    table_CountryName[ii, CI_975 := confint(model_int)["shutdown_2020", "97.5 %"] %>% exp() -1]
    table_CountryName[ii, p := coeftable(model_int)["shutdown_2020", "Pr(>|z|)"] ]
  }
  
  print(paste(ii, "regression is done."))
}

table_CountryName[p<0.05, .N]/table_CountryName[, .N]
# 显著变化国家比例竟达0.667, 远远超过OLS时的情景
dt_coef_country <- table_CountryName %>%
  .[order(coef)] %>%
  # Mongolia和Latvia异常的大, 我们先剔除.
  #.[coef < 10] %>%
  .[, number := 1:.N] %>%
  .[, width := fire_median/sum(fire_median) * .N] %>%
  .[, before_cum := cumsum(width) - width] %>%
  .[, med_point := before_cum + width/2] %>%
  # 根据显著性添加标签
  .[(coef > 0)&(p <  0.05), c("group_chr") := .("pos-sig")] %>%
  .[(coef > 0)&(p >= 0.05), c("group_chr") := .("pos-non")] %>%
  .[(coef < 0)&(p >= 0.05), c("group_chr") := .("neg-non")] %>%
  .[(coef < 0)&(p <  0.05), c("group_chr") := .("neg-sig")] %>%
  # 这一步单纯是为了绘图, coef值过大会影响Adobe AI中的操作
  # 因此我们将coef大于1.5的数值强行赋值为1.5
  # 在展示时只展示[-1, 1], 这一操作不会对绘图产生影响
  .[, raw_coef := coef] %>%
  .[coef > 1.5 , coef := 1.5]

#saveRDS(
#  dt_coef_country,
#  file.path(dir_data, "Main-3_2_dt_coef_country.rds")
#)



#-----------------------3: Regresion of the wolrd
##---------------3.1 modeling
fixed_glb <- feglm(
  fmla_fixed,
  panel_unbalance,
  family = "poisson",
  vcov = as.formula(paste0("~", vvar))
)

##---------------3.2 coefficients extraction
dt_coef_glb <- data.table(
  coef = NA, p = NA,
  CI_025 = NA, CI_975 = NA,
  se_low = NA, se_up = NA
  )

dt_coef_glb[
  ,
  c("coef", "p", "CI_025", "CI_975", "se_low", "se_up") := .(
    coeftable(fixed_glb)["shutdown_2020", "Estimate"] %>% exp() - 1,
    coeftable(fixed_glb)["shutdown_2020", "Pr(>|z|)"],
    confint(fixed_glb, level = 0.95)["shutdown_2020", "2.5 %"] %>% exp() -1,
    confint(fixed_glb, level = 0.95)["shutdown_2020", "97.5 %"] %>% exp() - 1,
      
    (coeftable(fixed_glb)["shutdown_2020", "Estimate"] -
        coeftable(fixed_glb)["shutdown_2020", "Std. Error"]) %>% exp() - 1,
    (coeftable(fixed_glb)["shutdown_2020", "Estimate"] +
        coeftable(fixed_glb)["shutdown_2020", "Std. Error"]) %>% exp() - 1
  )] %>%
  .[,
    label := paste0(
      sprintf("%0.1f", coef*100),
      "\n", "(",
      sprintf("%0.1f", CI_025*100), ",",
      "\n",
      sprintf("%0.1f", CI_975*100),
      ")"
    )
  ]
dt_coef_glb[p < 0.05, indicator := "significant"]



#-----------------------4: Plot
library(ggpattern)

dt_coef_country <- readRDS(
  file.path(dir_data, "Main-3_2_dt_coef_country.rds")
  ) %>%
  #不展示最小的Eritrea以及最大的Mongolia和Latvia这三个国家，避免不必要的干扰信息
  .[!(group_lab %in% c("Eritrea", "Mongolia", "Latvia"))] %>%
  # 由于国家数目调整, 需要调整展示点位
  .[order(coef)] %>%
  .[, number := 1:.N] %>%
  .[, width := fire_median/sum(fire_median) * .N] %>%
  .[, before_cum := cumsum(width) - width] %>%
  .[, med_point := before_cum + width/2]

# 从dt_coef_country中筛选出一些比较重要的国家, 在图片上标注出来
note_country <- dt_coef_country %>%
  .[group_lab %in% c(
    "Australia",
    "Thailand",
    "United States",
    #"Myanmar",
    "China",
    "Democratic Republic of Congo",
    "Russia",
    "Venezuela",
    "Mexico",
    "Colombia",
    "India",
    "Madagascar",
    "Angola"
  )] %>%
  .[coef < 0, y := 1] %>%
  .[coef > 0, y := -1]



ggplot(dt_coef_country) +
  geom_col_pattern(
    aes(
      x = med_point, y = coef*100,
      fill = Region,
      pattern = group_chr
    ),
    alpha = 0.5,
    width = dt_coef_country[, width],
    color = "white", linewidth = 0.1,
    
    pattern_color = "grey",
    pattern_fill = "grey",
    pattern_density = 0.01,
    pattern_spacing = 0.04
  ) +
  scale_pattern_manual(
    values = c(
      "neg-sig" = "stripe", "pos-sig" = "stripe",
      "neg-non" = "none",   "pos-non" = "none"
    ),
    guide = "none"
  ) +
  geom_hline(
    yintercept = 0, color = "black", linewidth = 0.2
  ) +
  geom_line(
    aes(x = med_point, y = coef*100)
  ) +
  annotate(
    "segment",
    x = 0,
    xend = dt_coef_country[1, med_point],
    y = dt_coef_country[1, coef*100],
    yend = dt_coef_country[1, coef*100]
  ) +
  # notable countries
  geom_text(
    aes(x = med_point, y = y, label = CountryCode),
    data = note_country,
    size = con_axis_text,
    vjust = "outward"
  ) +
  scale_y_continuous(
    breaks = seq(-100, 100, 50),
    labels = c(-100, -50, 0, 50, 100)
  ) +
  scale_fill_brewer(
    name = NULL,
    palette = "Set1",
    limits = c(
      "Africa", "Asia", "Europe",
      "Northern America", "Latin America and the Caribbean",  "Oceania"
    ),
    labels = c(
      "Africa", "Asia", "Europe",
      "Northern America", "Latin America", "Oceania"
    ),
    guide = guide_legend(
      override.aes = list(
        linewidth = 0.2, color = "black"
      )
    )
  ) +
  # overall effect in the shutdown period
  #annotate(
  #  "rect",
  #  xmin = nrow(dt_coef_country),
  #  xmax = nrow(dt_coef_country)*1.05,
  #  ymin = -Inf,
  #  ymax = Inf,
  #  fill = "grey90"
  #) +
  geom_vline(
    xintercept = nrow(dt_coef_country),
    color = "grey90",
    linetype = "solid", linewidth = 1
  ) +
  geom_linerange(
    aes(
      x = nrow(dt_coef_country)*1.025,
      ymin = CI_025*100, ymax = CI_975*100
    ),
    data = dt_coef_glb,
    linewidth = 2, lineend = "round", color = "#377EB8", alpha = 0.2
  ) +
  geom_linerange(
    aes(
      x = nrow(dt_coef_country)*1.025,
      ymin = se_low*100, ymax = se_up*100
    ),
    data = dt_coef_glb,
    linewidth = 2, lineend = "round", color = "#377EB8", alpha = 0.6
  ) +
  geom_point(
    aes(
      x = nrow(dt_coef_country)*1.025,
      y = coef*100
    ),
    data = dt_coef_glb,
    shape = 21, size = 2.5, color = "black", fill = "#377EB8"
  ) +
  geom_text(
    aes(
      x = nrow(dt_coef_country)*1.025,
      y = coef*100 - 30, label = label
    ),
    data = dt_coef_glb,
    size = con_axis_text * 0.8
  ) +
  coord_cartesian(
    xlim = c(0, nrow(dt_coef_country)*1.05),
    ylim = c(-100, 100),
    expand = FALSE
  ) +
  theme(
    panel.grid = element_blank(),
    panel.background = element_rect(fill = "white"),
    panel.border = element_rect(fill = NA, color = "black", linewidth = 0.2),
    
    legend.position = "inside",
    legend.position.inside = c(0, 1),
    legend.justification.inside = c(0, 1),
    legend.direction = "horizontal",
    legend.byrow = TRUE,
    legend.background = element_blank(),
    legend.title.position = "top",
    legend.title = element_text(size = con_axis_title*.pt),
    legend.text = element_text(size = con_axis_text*.pt),
    legend.key.size = unit(con_axis_text*1.5, units = "mm"),
    
    axis.text.x.bottom = element_blank(),
    axis.ticks.x.bottom = element_blank(),
    axis.text.y.left = element_text(size = con_axis_text*.pt),
    axis.title = element_text(size = con_axis_title*.pt),
    plot.title = element_text(size = con_axis_title*.pt, face = "bold"),
    plot.title.position = "plot"
  ) +
  labs(
    x = NULL,
    y = "Changes in fire incidence (%)",
    title = "B"
  )

#ggsave(
#  file.path(dir_figs, "fig2_b.pdf"),
#  width = 180, height = 70, units = "mm"
#)

```



# Figure 3


## Event Study


```{r}
#| label: fig3_event

# regression results in country level in figure 2
dt_coef_country <- readRDS(
  file.path(dir_data, "Main-3_2_dt_coef_country.rds")
)


#-----------------------1: Formula
yvar = "actfire_sum"
xvar = "i(week_to_2020, ref = c(-1000, -1))"
vvar = "intg_oxfordID^intg_biome"         # poisson残差不能用"iid", 否则异常显著
controls = "+ weather_tempe + weather_tempe_square + weather_winds + weather_preci + weather_RH + weather_VPD"
fe = "intg_oxfordID^intg_biome^week + intg_oxfordID^intg_biome^year"

fmla_event <- as.formula(
  paste(yvar, "~", xvar, controls, "|", fe)
)



#-----------------------2: Model
##---------------2.1 Global regression
event_glb <- feglm(
  fmla_event,
  panel_unbalance,
  family = "poisson",
  vcov = as.formula(paste0("~", vvar))
)
iplot(
  event_glb,
  xlim = c(-10, 15), ylim = c(-1, 1),
  xlab = "Week since shutdown", ylab = "Coefficients",
  main = "Shutdown effect on active fire in the world"
)


##---------------2.2 Countries with decreased fire
event_dec <- feglm(
  fmla_event,
  panel_unbalance[CountryName %in% dt_coef_country[coef < 0, group_lab]],
  family = "poisson",
  vcov = as.formula(paste0("~", vvar))
)
iplot(
  event_dec,
  xlim = c(-10, 15), ylim = c(-1, 1),
  xlab = "Week since shutdown", ylab = "Coefficients",
  main = "Shutdown effect on countries with decreased fires during the shutdown"
)


##---------------2.3 Countries with increased fire
event_inc <- feglm(
  fmla_event,
  panel_unbalance[CountryName %in% dt_coef_country[coef > 0, group_lab]],
  family = "poisson",
  vcov = as.formula(paste0("~", vvar))
)
iplot(
  event_inc,
  xlim = c(-10, 15), ylim = c(-1, 1),
  xlab = "Week since shutdown", ylab = "Coefficients",
  main = "Shutdown effect on countries with increased fires during the shutdown"
)

```


## A - Event of countries with decreased fire


```{r}
#| label: fig3_a

#-----------------------1: Extract coefficients
dt_fig3_a <- data.table(
  var_i = paste("week_to_2020", (-5:10), sep = "::"),
  week = -5:10,
  coef = NaN, p = NaN,
  CI_025 = NaN, CI_975 = NaN,
  se_low = NaN, se_up = NaN
  ) %>%
  .[week != -1]

for (ii in 1:nrow(dt_fig3_a)) {
  
  var_i_here <- dt_fig3_a[ii, var_i]
  
  dt_fig3_a[
    ii,
    c("coef", "p", "CI_025", "CI_975", "se_low", "se_up") := .(
      coeftable(event_dec)[var_i_here, "Estimate"] %>% exp() - 1,
      coeftable(event_dec)[var_i_here, "Pr(>|z|)"],
      confint(event_dec, level = 0.95)[var_i_here, "2.5 %"] %>% exp() -1,
      confint(event_dec, level = 0.95)[var_i_here, "97.5 %"] %>% exp() - 1,
      
      (coeftable(event_dec)[var_i_here, "Estimate"] -
         coeftable(event_dec)[var_i_here, "Std. Error"]) %>% exp() - 1,
      (coeftable(event_dec)[var_i_here, "Estimate"] +
         coeftable(event_dec)[var_i_here, "Std. Error"]) %>% exp() - 1
    )
  ]
}
dt_fig3_a[p < 0.05, indicator := "significant"]



#-----------------------2: Plot
ggplot(dt_fig3_a) +
  # auxiliary line and point
  geom_hline(yintercept = 0, linetype = "dashed", color = "grey") +
  geom_vline(xintercept = -1, linetype = "dashed", color = "grey") +
  annotate(
    "point",
    x = -1, y = 0, color = "grey40"
  ) +
  # coefficients of each week since shutdown
  geom_linerange(
    aes(
      x = week,
      ymin = CI_025*100, ymax = CI_975*100
    ),
    linewidth = 1, color = "#377EB8", alpha = 0.5
  ) +
  geom_linerange(
    aes(
      x = week,
      ymin = se_low*100, ymax = se_up*100
    ),
    linewidth = 2.5, color = "#377EB8", alpha = 0.5
  ) +
  geom_point(
    aes(
      x = week,
      y = coef*100,
      fill = indicator
    ),
    shape = 21, size = 3, color = "#377EB8"
  ) +
  scale_fill_manual(
    values = c("significant" = "#377EB8"),
    na.value = "white",
    guide = NULL
  ) +
  theme(
    plot.title.position = "plot",
    
    panel.grid = element_blank(),
    panel.background = element_rect(fill = "white"),
    axis.line.x.bottom = element_line(linewidth = con_axis_line*0.5),
    axis.line.y.left = element_line(linewidth = con_axis_line*0.5),
    
    axis.text.y.left = element_text(size = con_axis_text*.pt),
    axis.title.y.left = element_text(color = "black"),
    
    axis.text.x.bottom = element_text(size = con_axis_text*.pt),
    axis.title = element_text(size = con_axis_title*.pt),
    plot.title = element_text(size = con_axis_title*.pt, face = "bold")
  ) +
  labs(
    title = "A",
    x = "Weeks since mobility restriction",
    y = "Changes in fire incidence (%)"
  )


#ggsave(
#  file.path(dir_figs, "fig3_a.pdf"),
#  width = 90, height = 60, units = "mm"
#)

```


## B - Event of countries with increased fire


```{r}
#| label: fig3_b

#-----------------------1: Extract coefficients
dt_fig3_b <- data.table(
  var_i = paste("week_to_2020", (-5:10), sep = "::"),
  week = -5:10,
  coef = NaN, p = NaN,
  CI_025 = NaN, CI_975 = NaN,
  se_low = NaN, se_up = NaN
  ) %>%
  .[week != -1]

for (ii in 1:nrow(dt_fig3_b)) {
  
  var_i_here <- dt_fig3_b[ii, var_i]
  
  dt_fig3_b[
    ii,
    c("coef", "p", "CI_025", "CI_975", "se_low", "se_up") := .(
      coeftable(event_inc)[var_i_here, "Estimate"] %>% exp() - 1,
      coeftable(event_inc)[var_i_here, "Pr(>|z|)"],
      confint(event_inc, level = 0.95)[var_i_here, "2.5 %"] %>% exp() -1,
      confint(event_inc, level = 0.95)[var_i_here, "97.5 %"] %>% exp() - 1,
      
      (coeftable(event_inc)[var_i_here, "Estimate"] -
         coeftable(event_inc)[var_i_here, "Std. Error"]) %>% exp() - 1,
      (coeftable(event_inc)[var_i_here, "Estimate"] +
         coeftable(event_inc)[var_i_here, "Std. Error"]) %>% exp() - 1
    )
  ]
}
dt_fig3_b[p < 0.05, indicator := "significant"]



#-----------------------2: Plot
ggplot(dt_fig3_b) +
  # auxiliary line and point
  geom_hline(yintercept = 0, linetype = "dashed", color = "grey") +
  geom_vline(xintercept = -1, linetype = "dashed", color = "grey") +
  annotate(
    "point",
    x = -1, y = 0, color = "grey40"
  ) +
  # coefficients of each week since shutdown
  geom_linerange(
    aes(
      x = week,
      ymin = CI_025*100, ymax = CI_975*100
    ),
    linewidth = 1, color = "#E41A1C", alpha = 0.5
  ) +
  geom_linerange(
    aes(
      x = week,
      ymin = se_low*100, ymax = se_up*100
    ),
    linewidth = 2.5, color = "#E41A1C", alpha = 0.5
  ) +
  geom_point(
    aes(
      x = week,
      y = coef*100,
      fill = indicator
    ),
    shape = 21, size = 3, color = "#E41A1C"
  ) +
  scale_y_continuous(
    breaks = seq(0, 100, 25)
  ) +
  scale_fill_manual(
    values = c("significant" = "#E41A1C"),
    na.value = "white",
    guide = NULL
  ) +
  theme(
    plot.title.position = "plot",
    
    panel.grid = element_blank(),
    panel.background = element_rect(fill = "white"),
    axis.line.x.bottom = element_line(linewidth = con_axis_line*0.5),
    axis.line.y.left = element_line(linewidth = con_axis_line*0.5),
    
    axis.text.y.left = element_text(size = con_axis_text*.pt),
    axis.title.y.left = element_text(color = "black"),
    
    axis.text.x.bottom = element_text(size = con_axis_text*.pt),
    axis.title = element_text(size = con_axis_title*.pt),
    plot.title = element_text(size = con_axis_title*.pt, face = "bold")
  ) +
  labs(
    title = "B",
    x = "Weeks since mobility restriction",
    y = "Changes in fire incidence (%)"
  )


#ggsave(
#  file.path(dir_figs, "fig3_b.pdf"),
#  width = 90, height = 60, units = "mm"
#)

```


## Mobility Response


```{r}
#| label: fig3_b_mobility

# regression results in country level in figure 2
dt_coef_country <- readRDS(
  file.path(dir_data, "Main-3_2_dt_coef_country.rds")
)


#-----------------------1: Panel for spline
# Oxford dataset: full series from 2020.01.01 to 2020.12.31
# Mobility index:
#  - China: full series from 2020.01.01 to 2020.05.02
#  - World: series (maybe with missing values) from 2020.02.15 to 2020.12.31

panel_spline <- panel_unbalance %>%
  copy() %>%
  .[!is.na(intg_oxfordID)] %>%                        # 必须匹配上了牛津政策指数
  .[!is.na(intg_mobilityID)] %>%                      # 必须匹配上了移动性指数***
  #.[break_group == "lock-both"] %>%                # 这是新加的,一会儿跑一下试试
  # transform mobility_SI and mobility_index to original units first
  .[,
    `:=`(
      mobility_SI = mobility_SI / 100,
      mobility_index = mobility_index / 100
    )
  ] %>%
  # For mobility_SI, there are no NA and negative values during shutdown in 2020, as expected.
  # And all observations in 2016-2019 or before shutdown in 2020 are set as 0.
  # But for mobility_index, there are NA (21%) and negative values. We leaves NA alone.
  # Now we manually set the numbers bigger than 0(1%) as 0, and then 
  # transform the interval [-100, 0] to [0, 100]
  .[mobility_index > 0, mobility_index := 0] %>%
  .[, mobility_index := mobility_index * -1] %>%
  # spline coordinates for mobility_SI
  .[, paste0("ns_SI_", 1:4) := as.data.frame(
        splines::ns(
          mobility_SI,
          # SI的分布过于集中在后面了
          knots = c(50, 80, 95), intercept = FALSE,
          Boundary.knots = c(0, 100)
        )
    )] %>%
  # essential***
  .[shutdown_2020 == 0, paste0("ns_SI_", 1:4) := 0] %>%
  # spline coordinates for mobility_index
  .[, paste0("ns_mob_", 1:4) := as.data.frame(
        splines::ns(
          mobility_index,
          knots = c(20, 40, 60), intercept = FALSE,
          Boundary.knots = c(0, 100)
        )
    )] %>%
  # essential***
  .[shutdown_2020 == 0, paste0("ns_mob_", 1:4) := 0] %>%
  # for the following linear effect size
  .[shutdown_2020 == 0, mobility_index := 0]

panel_spline[shutdown_2020 == 1, summary(mobility_index)]
# Min. 1st Qu.  Median    Mean 3rd Qu.    Max.    NA's 
# 0.00   24.28   34.28   34.27   44.28   92.68       9
panel_spline[shutdown_2020 == 1, quantile(mobility_index, probs = seq(0, 1, 0.1), na.rm = TRUE)]
#   0%   10%   20%   30%   40%   50%   60%   70%   80%   90%  100% 
# 0.00 13.87 22.42 26.85 29.28 34.28 38.85 41.14 47.14 53.28 92.68
# 53.28*** account for 90% observations



#-----------------------2: Overall function
##---------------2.1 Simple overal response
func_curve <- function(
    rawdata,
    yvar = "actfire_sum",
    xvar = paste(paste0("ns_mob_", 1:4), collapse = " + "),
    controls = "+ weather_tempe + weather_tempe_square + weather_winds + weather_preci + weather_RH + weather_VPD",
    fe = "intg_oxfordID^intg_biome^week + intg_oxfordID^intg_biome^year",
    vvar = "intg_oxfordID^intg_biome",
    bd_kts = c(0, 100),
    kts = c(20, 40, 60),
    pts = 0:100
  ){
  
  nn <- length(kts) + 1                                           # no intercept
  
  #--------------1: Preparation
  # We have already calculated the spline coordinates for observations
  # during shutdown period in 2020, with knots at 20, 40 and 60 respectively.
  
  ##----1.1 formula
  fmla_spline <- as.formula(
    paste(yvar, "~", xvar, controls, "|", fe)
    )
  
  ##----1.2 spline transformation of fixed pts
  mat_pts <- as.matrix(
    splines::ns(pts, knots = kts, intercept = FALSE, Boundary.knots = bd_kts)
  )
  
  
  #--------------2: Regression
  model_spline <- feglm(
    fmla_spline,
    rawdata,
    family = "poisson",
    vcov = as.formula(paste0("~", vvar))
  )
  
  
  #--------------3: Response
  ##----3.1 coefficients
  vec_coef <- coef(model_spline)
  
  ##----3.2 response
  dt_response <- data.table(
    pts = pts,
    response = as.numeric(mat_pts %*% vec_coef[paste0("ns_mob_", 1:4)]) %>%
      exp() - 1
  )
  
  
  return(dt_response)
  
}


##---------------2.2 Model
###-----2.2.1 Global curve
curve_glb <- func_curve(
  panel_spline
)

ggplot(data = curve_glb) +
  geom_line(
    aes(x = pts, y = response)
  ) +
  coord_cartesian(
    xlim = c(-1, 80), ylim = c(-1, 1)
  ) +
  labs(
    x = "Mobility reduction (%)",
    y = "Relative changes in active fire",
    title = "Response curve of active fire in the world"
  )

###-----2.2.2 Countries with decreased fire
curve_dec <- func_curve(
  panel_spline[CountryName %in% dt_coef_country[coef < 0, group_lab]]
)

ggplot(data = curve_dec) +
  geom_line(
    aes(x = pts, y = response)
  ) +
  coord_cartesian(
    xlim = c(-1, 80), ylim = c(-1, 1)
  ) +
  labs(
    x = "Mobility reduction (%)",
    y = "Relative changes in active fire",
    title = "Response curve in countries with decreased fires"
  )


###-----2.2.3 Countries with increased fire
curve_inc <- func_curve(
  panel_spline[CountryName %in% dt_coef_country[coef > 0, group_lab]]
)

ggplot(data = curve_inc) +
  geom_line(
    aes(x = pts, y = response)
  ) +
  coord_cartesian(
    xlim = c(-1, 80), ylim = c(-1, 1)
  ) +
  labs(
    x = "Mobility reduction (%)",
    y = "Relative changes in active fire",
    title = "Response curve in countries with increased fires"
  )



#-----------------------3: Bootstrap regression
bootspline_mob <- function(
    rawdata,
    boot = 1000,
    seed = 182,
    yvar = "actfire_sum",
    xvar = paste(paste0("ns_mob_", 1:4), collapse = " + "),
    controls = "+ weather_tempe + weather_tempe_square + weather_winds + weather_preci + weather_RH + weather_VPD",
    fe = "intg_oxfordID^intg_biome^week + intg_oxfordID^intg_biome^year",
    vvar = "intg_oxfordID^intg_biome",
    bd_kts = c(0, 100),
    kts = c(20, 40, 60),
    pts = 0:100
  ) {
  
  nn <- length(kts) + 1                                           # no intercept
  
  #--------------1: Preparation
  # We have already calculated the spline coordinates for observations
  # during shutdown period in 2020, with knots at 20, 40 and 60 respectively.
  
  ##----1.1 formula
  fmla_spline <- as.formula(
    paste(yvar, "~", xvar, controls, "|", fe)
    )
  
  ##----1.2 spline transformation of fixed pts
  mat_pts <- as.matrix(
    splines::ns(pts, knots = kts, intercept = FALSE, Boundary.knots = bd_kts)
  )
  
  
  #--------------2: Bootstrap
  set.seed(seed)
  out_response_glb <- out_response_dec <- out_response_inc <- c()
  
  for (ii in 1:boot) {
    
    ##--2.1 make panel for each iteration
    ## sample intg_oxfordID with replacement
    samp <- data.table(
      unit = rawdata[,
        base::sample(
          x = unique(intg_oxfordID),
          size = length(unique(intg_oxfordID)),
          replace = TRUE
        )
      ]
    )
    
    ## join resampled intg_oxfordID
    sub_boot <- rawdata %>%
      merge(
        samp,
        by.x = "intg_oxfordID",  by.y = "unit",
        all = FALSE,  sort = FALSE,
        allow.cartesian = TRUE                        # allow duplicate joins***
      )
    
    ##--2.2 overall response
    model_spline_glb <- feglm(
      fmla_spline,
      sub_boot,
      family = "poisson",
      vcov = as.formula(paste0("~", vvar))
    )
    vec_coef_glb <- coef(model_spline_glb)[paste0("ns_mob_", 1:4)]
    vec_response_glb <- as.numeric(mat_pts %*% vec_coef_glb)
    out_response_glb <- cbind(out_response_glb, vec_response_glb)
    
    ##--2.3 countries with decreased fire
    model_spline_dec <- feglm(
      fmla_spline,
      sub_boot[CountryName %in% dt_coef_country[coef < 0, group_lab]],
      family = "poisson",
      vcov = as.formula(paste0("~", vvar))
    )
    vec_coef_dec <- coef(model_spline_dec)[paste0("ns_mob_", 1:4)]
    vec_response_dec <- as.numeric(mat_pts %*% vec_coef_dec)
    out_response_dec <- cbind(out_response_dec, vec_response_dec)

    ###-----2.2.3 Countries with increased fire
    model_spline_inc <- feglm(
      fmla_spline,
      sub_boot[CountryName %in% dt_coef_country[coef > 0, group_lab]],
      family = "poisson",
      vcov = as.formula(paste0("~", vvar))
    )
    vec_coef_inc <- coef(model_spline_inc)[paste0("ns_mob_", 1:4)]
    vec_response_inc <- as.numeric(mat_pts %*% vec_coef_inc)
    out_response_inc <- cbind(out_response_inc, vec_response_inc)
    
    
    print(paste0(ii, " is done."))
  }
  
  df_response_glb <- data.frame(pts, out_response_glb)
  df_response_dec <- data.frame(pts, out_response_dec)
  df_response_inc <- data.frame(pts, out_response_inc)
  
  list_all <- list(df_response_glb, df_response_dec, df_response_inc)
  return(list_all)
}

# 时间测试
#tt <- Sys.time()
#list_spline <- bootspline_mob(
#  panel_spline,
#  boot = 10
#)
#print(Sys.time() - tt)
# 10个循环, 用时为15.29131 mins.
# 那么换算到1000个循环, 用时约为26小时.
# 显示有缺失值是因为编号为904的移动性ID.
# 其匹配上的移动性数据是第7周以后才有的, 但根据政策数据第4周就发生了封锁
# 所以有一个mobility在2020年封锁时段内缺失数据的情况, 影响不大.

# 具体执行文件见Fire文件夹下的Main-3_2_bootstrap_mob.R.
#tt <- Sys.time()
#list_spline <- bootspline_mob(
#  panel_spline
#)
#print(Sys.time() - tt)                                         # 21.37024 hours
#saveRDS(list_spline, file.path(dir_data, "Main-3_2_bootstrap_curve.rds"))

```


## C - Response of countries with decreased fire


```{r}
#| label: fig3_c


#-----------------------1: Bootstrap coefficients
# rawdf contains initial simulated values.
# Now we extract the 95%CI and mean, return these summary statistics.
df_spline_mob <- readRDS(file.path(dir_data, "Main-3_2_bootstrap_curve.rds"))[[2]]

# We need to exponent these original coefficients at first.
mydf <- data.frame(
  pts = df_spline_mob[, "pts"],
  average = apply(
    df_spline_mob[, 2:dim(df_spline_mob)[2]], 1,
    function(x){exp(mean(x)) - 1}
  ),
  CI_low = apply(
    df_spline_mob[, 2:dim(df_spline_mob)[2]], 1,
    function(x){exp(quantile(x, probs = 0.025)) - 1}
  ),
  CI_up = apply(
    df_spline_mob[, 2:dim(df_spline_mob)[2]], 1,
    function(x){exp(quantile(x, probs = 0.975)) - 1}
  ),
  se_low = apply(
    df_spline_mob[, 2:dim(df_spline_mob)[2]], 1,
    function(x){exp(mean(x) - sd(x)) - 1}
  ),
  se_up = apply(
    df_spline_mob[, 2:dim(df_spline_mob)[2]], 1,
    function(x){exp(mean(x) + sd(x)) - 1}
  )
)



#-----------------------2: Sample distribution
# extract sample numbers in each bin for the histogram.
# set 1 as binwidth, from 0 to 100.

dt_number <- panel_spline %>%
  .[CountryName %in% dt_coef_country[coef < 0, group_lab]] %>%
  .[shutdown_2020 == 1] %>%
  # classify into intervals and type labels
  .[,
    interval := cut(
      mobility_index,
      breaks = seq(-0.5, 100.5, 1),
      labels = as.character(seq(0, 100, 1))
    )
  ] %>%
  # count numbers in each interval
  .[,
    .(count = .N),
    by = "interval"
  ] %>%
  .[, frequency := count/sum(count, na.rm = TRUE)] %>%
  .[order(interval)]
# set the frequency as the vertical height of each interval,
# while an interval needs two vertical lines at behind and after.
dt_before <- dt_number %>%
  .[interval != "0"] %>%    # exclude interval 0 to avoid conflict in histograms
  copy() %>%
  .[,
    `:=`(
      position = as.numeric(as.character(interval)) - 0.5,
      order = "a"
    )
  ]
dt_after <- dt_number %>%
  .[interval != "0"] %>%    # exclude interval 0 to avoid conflict in histograms
  copy() %>%
  .[,
    `:=`(
      position = as.numeric(as.character(interval)) + 0.5,
      order = "b"
    )
  ]
# for the final geom_path
dt_bins <- dt_before %>%
  rbind(dt_after) %>%
  .[order(interval, order)] %>%
  # assign the base height and multiply factor
  .[,
    `:=`(
      scale_frequency = -80 + 120*frequency,
      scale_base = -80
    )
  ]
# for the final geom_segment and geom_path
dt_obs_vertical <- dt_bins %>%
  # only keep a vertical line with max height in each position
  .[order(position, -frequency)] %>%
  .[, .SD[1], by = "position"]



#-----------------------3: Plot
ggplot(data = mydf) +
  geom_hline(yintercept = 0, linetype = "dashed", color = "grey") +
  geom_ribbon(
    aes(
      x = pts,
      ymin = CI_low*100, ymax = CI_up*100
    ),
    fill = "steelblue1", alpha = 0.1
  ) +
  geom_ribbon(
    aes(
      x = pts,
      ymin = se_low*100, ymax = se_up*100
    ),
    fill = "steelblue1", alpha = 0.2
  ) +
  geom_line(
    aes(
      x = pts,
      y = average*100
    ),
    color = "#377EB8", linewidth = 0.8
  ) +
  geom_segment(
    aes(
      x = position, xend = position,
      y = scale_base, yend = scale_frequency
    ),
    data = dt_obs_vertical,
    linewidth = 0.15
  ) +
  geom_path(
    aes(x = position, y = scale_frequency),
    data = dt_bins,
    linewidth = 0.15
  ) +
  theme(
    panel.grid = element_blank(),
    panel.background = element_rect(fill = "white"),
    
    axis.line.x.bottom = element_line(linewidth = con_axis_line*0.5),
    axis.line.y.left = element_line(linewidth = con_axis_line*0.5),
    
    plot.title.position = "plot",
    
    axis.text = element_text(size = con_axis_text*.pt),
    axis.title = element_text(size = con_axis_title*.pt),
    plot.title = element_text(size = con_plot_title*.pt, face = "bold"),
    plot.subtitle = element_text(size = con_plot_title*.pt)
  ) +
  scale_x_continuous(
    name = "Mobility reduction (%)",
    limits = c(0, 55.5),
    breaks = seq(0, 50, 10)
  ) +
  scale_y_continuous(
    name = "Response of fire incidence (%)",
    breaks = seq(0, -60, -20)
  ) +
  coord_cartesian(
    ylim = c(-80, 5), xlim = c(0, 55.5),
    expand = FALSE
  ) +
  labs(
    title = "C"
  )

#ggsave(
#  file.path(dir_figs, "fig3_c.pdf"),
#  width = 90, height = 60, units = "mm"
#)

```


## D - Response of countries with increased fire


```{r}
#| label: fig3_d


#-----------------------1: Bootstrap coefficients
# rawdf contains initial simulated values.
# Now we extract the 95%CI and mean, return these summary statistics.
df_spline_mob <- readRDS(file.path(dir_data, "Main-3_2_bootstrap_curve.rds"))[[3]]

# We need to exponent these original coefficients at first.
mydf <- data.frame(
  pts = df_spline_mob[, "pts"],
  average = apply(
    df_spline_mob[, 2:dim(df_spline_mob)[2]], 1,
    function(x){exp(mean(x)) - 1}
  ),
  CI_low = apply(
    df_spline_mob[, 2:dim(df_spline_mob)[2]], 1,
    function(x){exp(quantile(x, probs = 0.025)) - 1}
  ),
  CI_up = apply(
    df_spline_mob[, 2:dim(df_spline_mob)[2]], 1,
    function(x){exp(quantile(x, probs = 0.975)) - 1}
  ),
  se_low = apply(
    df_spline_mob[, 2:dim(df_spline_mob)[2]], 1,
    function(x){exp(mean(x) - sd(x)) - 1}
  ),
  se_up = apply(
    df_spline_mob[, 2:dim(df_spline_mob)[2]], 1,
    function(x){exp(mean(x) + sd(x)) - 1}
  )
)



#-----------------------2: Sample distribution
# extract sample numbers in each bin for the histogram.
# set 1 as binwidth, from 0 to 100.

dt_number <- panel_spline %>%
  .[CountryName %in% dt_coef_country[coef > 0, group_lab]] %>%
  .[shutdown_2020 == 1] %>%
  # classify into intervals and type labels
  .[,
    interval := cut(
      mobility_index,
      breaks = seq(-0.5, 100.5, 1),
      labels = as.character(seq(0, 100, 1))
    )
  ] %>%
  # count numbers in each interval
  .[,
    .(count = .N),
    by = "interval"
  ] %>%
  .[, frequency := count/sum(count, na.rm = TRUE)] %>%
  .[order(interval)]
# set the frequency as the vertical height of each interval,
# while an interval needs two vertical lines at behind and after.
dt_before <- dt_number %>%
  .[interval != "0"] %>%    # exclude interval 0 to avoid conflict in histograms
  copy() %>%
  .[,
    `:=`(
      position = as.numeric(as.character(interval)) - 0.5,
      order = "a"
    )
  ]
dt_after <- dt_number %>%
  .[interval != "0"] %>%    # exclude interval 0 to avoid conflict in histograms
  copy() %>%
  .[,
    `:=`(
      position = as.numeric(as.character(interval)) + 0.5,
      order = "b"
    )
  ]
# for the final geom_path
dt_bins <- dt_before %>%
  rbind(dt_after) %>%
  .[order(interval, order)] %>%
  # assign the base height and multiply factor
  .[,
    `:=`(
      scale_frequency = -10 + 135*frequency,
      scale_base = -10
    )
  ]
# for the final geom_segment and geom_path
dt_obs_vertical <- dt_bins %>%
  # only keep a vertical line with max height in each position
  .[order(position, -frequency)] %>%
  .[, .SD[1], by = "position"]



#-----------------------3: Plot
ggplot(data = mydf) +
  geom_hline(yintercept = 0, linetype = "dashed", color = "grey") +
  geom_ribbon(
    aes(
      x = pts,
      ymin = CI_low*100, ymax = CI_up*100
    ),
    fill = "indianred1", alpha = 0.1
  ) +
  geom_ribbon(
    aes(
      x = pts,
      ymin = se_low*100, ymax = se_up*100
    ),
    fill = "indianred1", alpha = 0.2
  ) +
  geom_line(
    aes(
      x = pts,
      y = average*100
    ),
    color = "#E41A1C", linewidth = 0.8
  ) +
  geom_segment(
    aes(
      x = position, xend = position,
      y = scale_base, yend = scale_frequency
    ),
    data = dt_obs_vertical,
    linewidth = 0.15
  ) +
  geom_path(
    aes(x = position, y = scale_frequency),
    data = dt_bins,
    linewidth = 0.15
  ) +
  theme(
    panel.grid = element_blank(),
    panel.background = element_rect(fill = "white"),
    
    axis.line.x.bottom = element_line(linewidth = con_axis_line*0.5),
    axis.line.y.left = element_line(linewidth = con_axis_line*0.5),
    
    plot.title.position = "plot",
    
    axis.text = element_text(size = con_axis_text*.pt),
    axis.title = element_text(size = con_axis_title*.pt),
    plot.title = element_text(size = con_plot_title*.pt, face = "bold"),
    plot.subtitle = element_text(size = con_plot_title*.pt)
  ) +
  scale_x_continuous(
    name = "Mobility reduction (%)",
    limits = c(0, 55.5),
    breaks = seq(0, 50, 10)
  ) +
  scale_y_continuous(
    name = "Response of fire incidence (%)",
  ) +
  coord_cartesian(
    ylim = c(-10, 85), xlim = c(0, 55.5),
    expand = FALSE
  ) +
  labs(
    title = "D"
  )

#ggsave(
#  file.path(dir_figs, "fig3_d.pdf"),
#  width = 90, height = 60, units = "mm"
#)

```


## Linear effect size

C和D中给出了响应曲线, 我们同时提取线性效应以便于论文叙述.

```{r}
#| label: fig3_linear_effect

# 我们直接提取得到是移动性每下降一个百分点, 对火点的影响.
# 如果叙述每10%下降的影响,需要相应乘上10.

#-----------------------1: Formula
yvar = "actfire_sum"
#xvar = paste(paste0("ns_mob_", 1:4), collapse = " + ")
xvar = "mobility_index"
controls = "+ weather_tempe + weather_tempe_square + weather_winds + weather_preci + weather_RH + weather_VPD"
fe = "intg_oxfordID^intg_biome^week + intg_oxfordID^intg_biome^year"
vvar = "intg_oxfordID^intg_biome"

fmla_linear <- as.formula(
  paste(yvar, "~", xvar, controls, "|", fe)
)



#-----------------------2: Countries with decreased fire
model_linear_dec <- feglm(
  fmla_linear,
  panel_spline[CountryName %in% dt_coef_country[coef < 0, group_lab]],
  family = "poisson",
  vcov = as.formula(paste0("~", vvar))
)

coeftable(model_linear_dec)[xvar, "Estimate"] %>% exp() - 1                  # -0.0132864
coeftable(model_linear_dec)[xvar, "Pr(>|z|)"]                                #  7.33481e-07
confint(model_linear_dec, level = 0.95)[xvar, "2.5 %"] %>% exp() -1          # -0.01849587
confint(model_linear_dec, level = 0.95)[xvar, "97.5 %"] %>% exp() - 1        # -0.008049285



#-----------------------3: Countries with increased fire
model_linear_inc <- feglm(
  fmla_linear,
  panel_spline[CountryName %in% dt_coef_country[coef > 0, group_lab]],
  family = "poisson",
  vcov = as.formula(paste0("~", vvar))
)

coeftable(model_linear_inc)[xvar, "Estimate"] %>% exp() - 1                  #  0.007635545
coeftable(model_linear_inc)[xvar, "Pr(>|z|)"]                                #  1.348155e-08
confint(model_linear_inc, level = 0.95)[xvar, "2.5 %"] %>% exp() -1          #  0.004994156
confint(model_linear_inc, level = 0.95)[xvar, "97.5 %"] %>% exp() - 1        #  0.01028388

```



# Figure 4

Exact interval by active fire point
我们根据火点的精确坐标提取到了各个属性变量

## Data preparation

```{r}
#| label: exact_data

# exact_footprint: 火点所在1km格网上的human footprint level
# exact_modification: 火点所在1km格网上的human modification gradient
# exact_PA_ratio:  火点所在0.05°格网上的保护区面积占比
# exact_PA_binary: 火点所在0.05°格网, 依据0.5这一阈值区分是(1)否(0)是保护区.
# exact_MCD12Q1: 火点所在500m格网的土地覆被精细分类.
# exact_MCD12Q1_agg: 火点所在500m格网的土地覆被聚合分类.
# WUI_type_nature: 火点所在10m格网的属性值(有0-8九个数值, 0为海洋)
# WUI_dist_nature: 火点所在100km×100km切片内, 距离切片内部最近WUI的距离(单位为米)



#-----------------------1: 读取匹配了精细属性的火点数据
rawdt_exact_combine <- fread(
  file.path(dir_input, "WUI_nature/dt_exact_combine.csv")
)
str(rawdt_exact_combine)
names(rawdt_exact_combine)
# "id_in_year", "longitude", "latitude", "acq_date", "frp", "year"              
# "exact_footprint", "exact_modification", "exact_PA_ratio", "exact_PA_binary",
# "exact_MCD12Q1",   "exact_MCD12Q1_agg",  "tile_MCD12Q1",
# "WUI_type_nature", "WUI_dist_nature",    "tile_WUI"
# 我们依据火点的观测时间为其匹配周次变量;
# 我们依据火点经纬度坐标为其匹配对应的0.5°格网.



#-----------------------2: 关联日期, 格网编号并进行初步筛选
##---------------2.1 识别日期对应的周次
# 由于lubridate::week计算效率过低,
# 我们先直接计算出每一天对应的年份和周次, 然后根据日期字符串进行关联.
date_match <- data.table(
  date = seq(from = ymd(20160101), to = ymd(20201231), by = "1 day")
  ) %>%
  .[, week := week(date)] %>%
  .[,
    `:=`(
      date = as.character(date),
      week = as.integer(week)
    )
  ]


##---------------2.2 全球0.5°格网编号
intg_pixelID <- rast(
  file.path(dir_input, "data_aggregation/intg_pixelID_pt5.tif")
)


##---------------2.3 组合原始面板中的id和week变量
# 后续需要对火点数据开展基于footprint和modification的分组异质性建模.
# 之前我们用的是全部的火点数据去等分分组, 但这样其实得到的并不是真正的等分,
# 更准确的做法应当是只保留研究时段内的火点观测值,
# 也就是panel_unbalance中"id"和"week"构成的组合变量.
filt_comb <- panel_unbalance %>%
  .[, .SD[1], by = c("id", "week")] %>%
  .[,
    filt_comb := paste(id, week, sep = "_")
  ] %>%
  .[, filt_comb]
print(object.size(filt_comb), unit = "Mb")                               # 62 Mb


##---------------2.4 制作后续使用的火点数据
dt_exact_combine <- rawdt_exact_combine %>%
  .[, acq_date := as.character(acq_date)] %>%
  # 关联与日期对应的年份和周次
  merge(
    date_match,
    by.x = "acq_date",
    by.y = "date",
    all.x= TRUE,
    sort = FALSE
  ) %>%
  # 根据经纬度提取其所在0.5°格网的编号
  .[,
    "id" := terra::extract(
      intg_pixelID,
      data.frame(
        x = longitude,
        y = latitude
      ),
      ID = FALSE
    )
  ] %>%
  # 制作0.5°格网编号与周次的组合变量
  .[,
    id_week := paste(id, week, sep = "_")
  ] %>%
  .[id_week %in% filt_comb] %>%
  .[, id_week := NULL]

nrow(dt_exact_combine)
# 27497294
# 火点数目从原来的82744585减少到了现在的27497294, 降幅达到66.7%



#-----------------------3: Formula
yvar = "actfire_sum_int"
xvar = "shutdown_2020"
vvar = "intg_oxfordID^intg_biome"
controls = "+ weather_tempe + weather_tempe_square + weather_winds + weather_preci + weather_RH + weather_VPD"
fe = "intg_oxfordID^intg_biome^week + intg_oxfordID^intg_biome^year"

fmla_fixed <- as.formula(
  paste(yvar, "~", xvar, controls, "|", fe)
)
```


## 1 - Landcover

四组分类:
1 - Forest
2 - Shrub/Savanna
3 - Grass
4 - Cropland


```{r}
#| label: fig4_landcover

# exact_MCD12Q1_agg:
# 1 - Forest
# 2 - Shrub/Savanna
# 3 - Grass
# 4 - Cropland
# 0 - Other
# 17 - Water Bodies

#-----------------------1: Landcover数据整理
dt_exact_combine[, table(exact_MCD12Q1_agg)]
#      0         1           2         3         4     17
# 422838   4494746    14734894   4868953   2974226   1637
dt_exact_combine[, table(exact_MCD12Q1_agg)]/dt_exact_combine[, .N]*100
#    0       1       2       3       4     17 
# 1.54   16.35   53.59   17.71   10.82   0.01

dt_MCD12Q1_agg <- dt_exact_combine %>%
  .[!is.na(exact_MCD12Q1_agg)] %>%
  # 计算格网每周的火点数目
  .[,
    .(actfire_sum_int = .N),
    by = c("id", "year", "week", "exact_MCD12Q1_agg")
  ] %>%
  # 格网和周次之间可能存在缺失组合, 我们进行补齐.
  tidytable::complete(
    id, year, week, exact_MCD12Q1_agg, fill = list(actfire_sum_int = 0)
  ) %>%
  setDT() %>%
  .[order(id, year, week, exact_MCD12Q1_agg)]
# 验证了组合数目, 没有问题.

# 将MCD12Q1_agg土地覆被分类与原始面板相结合
panel_MCD12Q1_agg <- panel_unbalance %>%
  merge(
    dt_MCD12Q1_agg,
    by = c("id", "year", "week"),
    all = FALSE, sort = FALSE,
    allow.cartesian = TRUE                                         # important *
  )
nrow(panel_MCD12Q1_agg)                                               # 22357140



#-----------------------2: Group information
table_MCD12Q1_agg <- data.table(
  group_var = "exact_MCD12Q1_agg",
  group_num = 1:4L,
  group_lab = c("Forest", "Shrub/Savanna", "Grass", "Cropland")
  ) %>%
  # 添加系数用于后续填充, NaN是为了让变量类型为数值型.
  .[,
    c("coef", "CI_025", "CI_975", "p", "se_low", "se_up") := NaN
  ]



#-----------------------3: Model
##---------------3.1 Regression for each group
for (ii in 1:nrow(table_MCD12Q1_agg)) {
  
  model_int <- feglm(
    fmla_fixed,
    panel_MCD12Q1_agg[
      get(table_MCD12Q1_agg[ii, group_var]) == table_MCD12Q1_agg[ii, group_num]
    ],
    family = "poisson",
    vcov = as.formula(paste0("~", vvar))
  )
  
  
  if("shutdown_2020" %in% names(coef(model_int))){
    table_MCD12Q1_agg[ii, coef := coef(model_int)[["shutdown_2020"]] %>% exp() - 1]
    table_MCD12Q1_agg[ii, CI_025 := confint(model_int)["shutdown_2020", "2.5 %"] %>% exp() - 1]
    table_MCD12Q1_agg[ii, CI_975 := confint(model_int)["shutdown_2020", "97.5 %"] %>% exp() - 1]
    table_MCD12Q1_agg[ii, p := coeftable(model_int)["shutdown_2020", "Pr(>|z|)"] ]
    table_MCD12Q1_agg[ii, se_low := (coeftable(model_int)["shutdown_2020", "Estimate"] -
         coeftable(model_int)["shutdown_2020", "Std. Error"]) %>% exp() - 1]
    table_MCD12Q1_agg[ii, se_up := (coeftable(model_int)["shutdown_2020", "Estimate"] +
         coeftable(model_int)["shutdown_2020", "Std. Error"]) %>% exp() - 1]
  }
  
  print(paste(ii, "regression is done."))
}

```


## 2 - PA


```{r}
#| label: fig4_PA

# exact_PA_binary
# 0 - 火点所在0.05°格网上保护区面积占比不超过0.5
# 1 - 火点所在0.05°格网上保护区面积占比超过了0.5

#-----------------------1: PA数据整理
dt_exact_combine[, table(exact_PA_binary)]
#        0        1
# 23716036  3781258
dt_exact_combine[, table(exact_PA_binary)]/dt_exact_combine[, .N]*100
#     0       1 
# 86.25   13.75

dt_PA <- dt_exact_combine %>%
  .[!is.na(exact_PA_binary)] %>%
  # 计算格网每周的火点数目
  .[,
    .(actfire_sum_int = .N),
    by = c("id", "year", "week", "exact_PA_binary")
  ] %>%
  # 格网和周次之间可能存在缺失组合, 我们进行补齐.
  tidytable::complete(
    id, year, week, exact_PA_binary, fill = list(actfire_sum_int = 0)
  ) %>%
  setDT() %>%
  .[order(id, year, week, exact_PA_binary)]
# 验证了组合数目, 没有问题.

# 将MCD12Q1_agg土地覆被分类与原始面板相结合
panel_PA <- panel_unbalance %>%
  merge(
    dt_PA,
    by = c("id", "year", "week"),
    all = FALSE, sort = FALSE,
    allow.cartesian = TRUE                                         # important *
  )
nrow(panel_PA)                                                         # 7452380



#-----------------------2: Group information
table_PA <- data.table(
  group_var = "exact_PA_binary",
  group_num = 0:1L,
  group_lab = c("Non-Protected", "Protected Area")
  ) %>%
  # 添加系数用于后续填充, NaN是为了让变量类型为数值型.
  .[,
    c("coef", "CI_025", "CI_975", "p", "se_low", "se_up") := NaN
  ]



#-----------------------3: Model
##---------------3.1 Regression for each group
for (ii in 1:nrow(table_PA)) {
  
  model_int <- feglm(
    fmla_fixed,
    panel_PA[
      get(table_PA[ii, group_var]) == table_PA[ii, group_num]
    ],
    family = "poisson",
    vcov = as.formula(paste0("~", vvar))
  )
  
  
  if("shutdown_2020" %in% names(coef(model_int))){
    table_PA[ii, coef := coef(model_int)[["shutdown_2020"]] %>% exp() - 1]
    table_PA[ii, CI_025 := confint(model_int)["shutdown_2020", "2.5 %"] %>% exp() - 1]
    table_PA[ii, CI_975 := confint(model_int)["shutdown_2020", "97.5 %"] %>% exp() - 1]
    table_PA[ii, p := coeftable(model_int)["shutdown_2020", "Pr(>|z|)"] ]
    table_PA[ii, se_low := (coeftable(model_int)["shutdown_2020", "Estimate"] -
         coeftable(model_int)["shutdown_2020", "Std. Error"]) %>% exp() - 1]
    table_PA[ii, se_up := (coeftable(model_int)["shutdown_2020", "Estimate"] +
         coeftable(model_int)["shutdown_2020", "Std. Error"]) %>% exp() - 1]
  }
  
  print(paste(ii, "regression is done."))
}

```


## 3 - Footprint


```{r}
#| label: fig4_footprint

#-----------------------1: Footprint数据整理
dt_exact_combine[, sum(is.na(exact_footprint))] / dt_exact_combine[, .N]
# 缺失值占比: 0.001
dt_exact_combine[, quantile(exact_footprint, probs = seq(0, 1, 0.25), na.rm = TRUE)]
# 0%     25%     50%      75%  100% 
#  0    4.74    8.71    14.56    50

dt_footprint <- dt_exact_combine %>%
  # 基于火点所在精细格网的人类足迹指数, 对火点进行分区
  .[,
    int_footprint := classify_intervals(
      exact_footprint, n = 4, style = "quantile", factor = FALSE
    )
  ] %>%
  .[!is.na(int_footprint)] %>%
  # 计算格网每周的火点数目
  .[,
    .(actfire_sum_int = .N),
    by = c("id", "year", "week", "int_footprint")
  ] %>%
  # 格网和周次之间可能存在缺失组合, 我们进行补齐.
  tidytable::complete(
    id, year, week, int_footprint, fill = list(actfire_sum_int = 0)
  ) %>%
  setDT() %>%
  .[order(id, year, week, int_footprint)]
# 验证了组合数目, 没有问题.

# 将footprint分区与原始面板相结合
panel_footprint <- panel_unbalance %>%
  merge(
    dt_footprint,
    by = c("id", "year", "week"),
    all = FALSE, sort = FALSE,
    allow.cartesian = TRUE                                         # important *
  )
nrow(panel_footprint)                                                 # 14899440


#-----------------------2: Group information
table_footprint <- data.table(
  group_var = "int_footprint",
  group_num = 1:4L,
  group_lab = levels(classify_intervals(
    dt_exact_combine$exact_footprint, n = 4, style = "quantile"
    ))
  ) %>%
  # 添加系数用于后续填充, NaN是为了让变量类型为数值型.
  .[,
    c("coef", "CI_025", "CI_975", "p", "se_low", "se_up") := NaN
  ]



#-----------------------3: Model
##---------------3.1 Regression for each group
for (ii in 1:nrow(table_footprint)) {
  
  model_int <- feglm(
    fmla_fixed,
    panel_footprint[
      get(table_footprint[ii, group_var]) == table_footprint[ii, group_num]
    ],
    family = "poisson",
    vcov = as.formula(paste0("~", vvar))
  )
  
  
  if("shutdown_2020" %in% names(coef(model_int))){
    table_footprint[ii, coef := coef(model_int)[["shutdown_2020"]] %>% exp() - 1]
    table_footprint[ii, CI_025 := confint(model_int)["shutdown_2020", "2.5 %"] %>% exp() - 1]
    table_footprint[ii, CI_975 := confint(model_int)["shutdown_2020", "97.5 %"] %>% exp() - 1]
    table_footprint[ii, p := coeftable(model_int)["shutdown_2020", "Pr(>|z|)"] ]
    table_footprint[ii, se_low := (coeftable(model_int)["shutdown_2020", "Estimate"] -
         coeftable(model_int)["shutdown_2020", "Std. Error"]) %>% exp() - 1]
    table_footprint[ii, se_up := (coeftable(model_int)["shutdown_2020", "Estimate"] +
         coeftable(model_int)["shutdown_2020", "Std. Error"]) %>% exp() - 1]
  }
  
  print(paste(ii, "regression is done."))
}

```


## 4 - Distance to the nearst WUI


```{r}
#| label: fig4_distance

# WUI_type_nature: 火点落在原始WUI切片中的格网类型
# WUI_dist_nature: 火点距离同一切片中最近WUI的距离(单位: m)

# https://zenodo.org/record/7941460
# 原始WUI中的格网类型:
# 1 - Forest/Shrubland/Wetland-dominated Intermix WUI
# 2 - Forest/Shrubland/Wetland-dominated Interface WUI
# 3 - Grassland-dominated Intermix WUI
# 4 - Grassland -dominated Interface WUI
# 5 - Non-WUI: Forest/Shrub/Wetland-dominated
# 6 - Non-WUI: Grassland-dominated
# 7 - Non-WUI: Urban
# 8 - Non-WUI: Other
# 具体产品数据中还有0值, 对应的当为水体.
# 发生在水体上的火点应当是由中心点误差引起的. 因此这里我们不对火点进行筛选.

#-----------------------1: WUI数据整理
dt_exact_combine[, sum(is.na(WUI_dist_nature))] / dt_exact_combine[, .N]
# 缺失值占比: 0.022
dt_exact_combine[, quantile(WUI_dist_nature, probs = seq(0, 1, 0.1), na.rm = TRUE)]
# 0%  10%    20%    30%    40%    50%    60%    70%     80%     90%     100% 
# 0   416   1023   1670   2447   3467   4918   7215   11396   21392   136165

# 可以看到将近90%的火点都落在距离WUI20公里的范围内.
# 这里我们只保留20km以内的火点, 采用4分位法.

dt_distance <- dt_exact_combine %>%
  # 只保留20km以内的火点
  .[WUI_dist_nature <= 20*10^3] %>%
  # 基于火点和最近WUI之间的距离, 对火点进行分类
  .[,
    int_distance := classify_intervals(
      WUI_dist_nature, n = 4, style = "quantile", factor = FALSE     # 单位是米
    )
  ] %>%
  .[!is.na(int_distance)] %>%
  # 计算格网每周的火点数目
  .[,
    .(actfire_sum_int = .N),
    by = c("id", "year", "week", "int_distance")
  ] %>%
  # 格网和周次之间可能存在缺失组合, 我们进行补齐.
  tidytable::complete(
    id, year, week, int_distance, fill = list(actfire_sum_int = 0)
  ) %>%
  setDT() %>%
  .[order(id, year, week, int_distance)]
# 验证了组合数目, 没有问题.

# 将WUI距离分区与原始面板相结合
panel_distance <- panel_unbalance %>%
  merge(
    dt_distance,
    by = c("id", "year", "week"),
    all = FALSE, sort = FALSE,
    allow.cartesian = TRUE                                         # important *
  )
nrow(panel_distance)                                                  # 12948400


#-----------------------2: Group information
table_distance <- data.table(
  group_var = "int_distance",
  group_num = 1:4L,
  group_lab = levels(classify_intervals(
    dt_exact_combine[WUI_dist_nature <= 20*10^3, WUI_dist_nature],
    n = 4, style = "quantile"
    ))
  ) %>%
  # 添加系数用于后续填充, NaN是为了让变量类型为数值型.
  .[,
    c("coef", "CI_025", "CI_975", "p", "se_low", "se_up") := NaN
  ]



#-----------------------3: Model
##---------------3.1 Regression for each group
for (ii in 1:nrow(table_distance)) {
  
  model_int <- feglm(
    fmla_fixed,
    panel_distance[
      get(table_distance[ii, group_var]) == table_distance[ii, group_num]
    ],
    family = "poisson",
    vcov = as.formula(paste0("~", vvar))
  )
  
  
  if("shutdown_2020" %in% names(coef(model_int))){
    table_distance[ii, coef := coef(model_int)[["shutdown_2020"]] %>% exp() - 1]
    table_distance[ii, CI_025 := confint(model_int)["shutdown_2020", "2.5 %"] %>% exp() - 1]
    table_distance[ii, CI_975 := confint(model_int)["shutdown_2020", "97.5 %"] %>% exp() - 1]
    table_distance[ii, p := coeftable(model_int)["shutdown_2020", "Pr(>|z|)"] ]
    table_distance[ii, se_low := (coeftable(model_int)["shutdown_2020", "Estimate"] -
         coeftable(model_int)["shutdown_2020", "Std. Error"]) %>% exp() - 1]
    table_distance[ii, se_up := (coeftable(model_int)["shutdown_2020", "Estimate"] +
         coeftable(model_int)["shutdown_2020", "Std. Error"]) %>% exp() - 1]
  }
  
  print(paste(ii, "regression is done."))
}




#table_distance
#saveRDS(
#  table_distance,
#  file.path(dir_data, "table_distance.rds")
#)
```


## 0 - Overall


```{r}
#| label: fig4_overall


#-----------------------1: Model of the whold
#----------------1.1 formula
yvar = "actfire_sum"
xvar = "shutdown_2020"
vvar = "intg_oxfordID^intg_biome"
controls = "+ weather_tempe + weather_tempe_square + weather_winds + weather_preci + weather_RH + weather_VPD"
fe = "intg_oxfordID^intg_biome^week + intg_oxfordID^intg_biome^year"

fmla_overall <- as.formula(
  paste(yvar, "~", xvar, controls, "|", fe)
)


##---------------1.2 reegresion
fixed_glb <- feglm(
  fmla_overall,
  panel_unbalance,
  family = "poisson",
  vcov = as.formula(paste0("~", vvar))
)


##---------------1.3 extract coefficients
table_overall <- data.table(
  group_var = "overall",
  group_num = 1L,
  group_lab = "overall"
  ) %>%
  # 添加系数用于后续填充, NaN是为了让变量类型为数值型.
  .[,
    c("coef", "CI_025", "CI_975", "p", "se_low", "se_up") := NaN
  ]

table_overall[1, coef := coef(fixed_glb)[["shutdown_2020"]] %>% exp() - 1]
table_overall[1, CI_025 := confint(fixed_glb)["shutdown_2020", "2.5 %"] %>% exp() - 1]
table_overall[1, CI_975 := confint(fixed_glb)["shutdown_2020", "97.5 %"] %>% exp() - 1]
table_overall[1, p := coeftable(fixed_glb)["shutdown_2020", "Pr(>|z|)"] ]
table_overall[1, se_low := (coeftable(fixed_glb)["shutdown_2020", "Estimate"] -
      coeftable(fixed_glb)["shutdown_2020", "Std. Error"]) %>% exp() - 1]
table_overall[1, se_up := (coeftable(fixed_glb)["shutdown_2020", "Estimate"] +
      coeftable(fixed_glb)["shutdown_2020", "Std. Error"]) %>% exp() - 1]



#-----------------------2: combine results
dt_fig4_coef_all <- rbindlist(
  list(
    table_overall,
    table_MCD12Q1_agg,
    table_PA,
    table_footprint,
    table_distance
  )
)

#saveRDS(
#  dt_fig4_coef_all,
#  file.path(dir_data, "dt_fig4_coef_all.rds")
#)
```


## Plot


```{r}

library(grid)
library(forestploter)
library(data.table)
library(magrittr)
library(ggplot2)



raw_coef <- readRDS(
  file.path(dir_data, "dt_fig4_coef_all.rds")
)


#-----------------------1: 制作适用于绘图的数据框
dt_fig4_plot <- raw_coef %>%
  copy() %>%
  # 将系数表示为百分比的形式
  .[,
    `:=`(
      coef = coef *100,
      CI_025 = CI_025*100,
      CI_975 = CI_975*100,
      se_low = se_low*100,
      se_up = se_up*100
    )
  ] %>%
  # 展示估计系数和置信区间
  .[,
    "Effect size (% [95% CI])" :=
      paste0(
        stringr::str_pad(sprintf("%.1f", coef),   5, pad = " "),
        " [",
        stringr::str_pad(sprintf("%.1f", CI_025), 5, pad = " "),
        ", ",
        stringr::str_pad(sprintf("%.1f", CI_975), 4, pad = " "),
        "]"
      )
  ] %>%
  .[c(
    1,
    2, 2:5L,
    6, 6:7L,
    8, 8:11L,
    12, 12:15L
    ),
    3:10
  ] %>%
  # Overall
  .[1,
    group_lab := "Overall"
  ] %>%
  # Landcover
  .[2,
    names(.) := 
      .("Landcover", NaN, NaN, NaN, NaN, NaN, NaN, "")
  ] %>%
  # Protected area
  .[7,
    names(.) := 
      .("Protected area", NaN, NaN, NaN, NaN, NaN, NaN, "")
  ] %>%
  .[9,
    group_lab := "Protected area"
  ] %>%
  # Footprint interval [0, 50]
  .[10,
    names(.) := 
      .("Footprint interval", NaN, NaN, NaN, NaN, NaN, NaN, "")
  ] %>%
  .[11:14,
    group_lab := c(
      "Low [0, 25%)",
      "Lower middle [25%, 50%)",
      "Upper middle [50%, 75%)",
      "High [75%, 100%]"
    )
  ] %>%
  # Distance to the nearest WUI
  .[15,
    names(.) := 
      .("Distance to the nearest WUI", NaN, NaN, NaN, NaN, NaN, NaN, "")
  ] %>%
  .[16:19,
    group_lab := c(
      "Near [0, 25%)",
      "Relatively near [25%, 50%)",
      "Relatively far [50%, 75%)",
      "Far [75%, 100%]"
    )
  ] %>%
  setnames(
    old = "group_lab", new = "Group"
  ) %>%
  # 绘图用的大小
  .[, ` ` := paste(rep(" ", 20), collapse = " ")] %>%
  .[,
    .(Group, coef, CI_025, CI_975, se_low, se_up, ` `, `Effect size (% [95% CI])`)
  ] %>%
  .[!is.na(coef),
    Group := paste0("   ", Group)
  ]

dt_fig4_plot[, min(CI_025, na.rm = TRUE)]                             # -37.9955
dt_fig4_plot[, max(CI_975, na.rm = TRUE)]                             #   7.9328


#-----------------------2: Plot
c("#984EA3", "#4DAF4A", "#377EB8", "#E41A1C")

p <- forest(
  dt_fig4_plot[, c(1, 7, 8)],
  est = dt_fig4_plot[, coef],
  lower = dt_fig4_plot[, CI_025], 
  upper = dt_fig4_plot[, CI_975],
  sizes = 1,
  ci_column = 2,
  ref_line = 0,
  xlim = c(-40, 10),
  ticks_at = c(-40, -30, -20, -10, 0, 10),
  
  theme = forest_theme(
    base_size = 10,
    
    #core=list(fg_params=list(hjust = 1, x = 0.9))
    core = list(
      bg_params = list(
        fill = "white"
      )
    ),
    
    # Reference line width/type/color
    refline_gp = gpar(lwd = 1, lty = "dashed", col = "grey"),
    
    ci_pch = 21,
    ci_lty = 1,
    ci_lwd = 1.5,
    ci_Theight = 0.2
  )
) %>%
  edit_plot(col = 2, row = 1,  which = "ci", gp = gpar(col = "black", fill = "black")) %>%
  edit_plot(col = 2, row = 3,  which = "ci", gp = gpar(col = "#377EB8", fill = "#377EB8")) %>%
  edit_plot(col = 2, row = 4,  which = "ci", gp = gpar(col = "#377EB8", fill = NULL)) %>%
  edit_plot(col = 2, row = 5,  which = "ci", gp = gpar(col = "#377EB8", fill = "#377EB8")) %>%
  edit_plot(col = 2, row = 6,  which = "ci", gp = gpar(col = "#377EB8", fill = NULL)) %>%
  edit_plot(col = 2, row = 8,  which = "ci", gp = gpar(col = "#E41A1C", fill = "#E41A1C")) %>%
  edit_plot(col = 2, row = 9,  which = "ci", gp = gpar(col = "#E41A1C", fill = NULL)) %>%
  edit_plot(col = 2, row = 11, which = "ci", gp = gpar(col = "#984EA3", fill = "#984EA3")) %>%
  edit_plot(col = 2, row = 12, which = "ci", gp = gpar(col = "#984EA3", fill = "#984EA3")) %>%
  edit_plot(col = 2, row = 13, which = "ci", gp = gpar(col = "#984EA3", fill = NULL)) %>%
  edit_plot(col = 2, row = 14, which = "ci", gp = gpar(col = "#984EA3", fill = NULL)) %>%
  edit_plot(col = 2, row = 16, which = "ci", gp = gpar(col = "#4DAF4A", fill = NULL)) %>%
  edit_plot(col = 2, row = 17, which = "ci", gp = gpar(col = "#4DAF4A", fill = NULL)) %>%
  edit_plot(col = 2, row = 18, which = "ci", gp = gpar(col = "#4DAF4A", fill = "#4DAF4A")) %>%
  edit_plot(col = 2, row = 19, which = "ci", gp = gpar(col = "#4DAF4A", fill = "#4DAF4A")) %>%
  edit_plot(
    col = 2, row = 
  ) %>%
  edit_plot(
    row = c(2, 7, 10, 15), which = "background",
    gp = gpar(fill = "grey95")
  ) %>%
  edit_plot(
    col = 3, row = 1:19, which = "text",
    hjust = unit(1, "npc"),
    x = unit(0.9, "npc")
  )

# Print plot
plot(p)


get_wh(p, unit = "mm")
#    width   height 
# 142.1208 132.7432


ggsave(
  filename = file.path(dir_figs, "fig4.pdf"),
  plot = p,
  width = get_wh(p, unit = "mm")[[1]], 
  height = get_wh(p, unit = "mm")[[2]],
  units = "mm",
)

#ggsave(
#  filename = file.path(dir_figs, "fig4.png"),
#  plot = p,
#  dpi = 300,
#  width = get_wh(p, unit = "mm")[[1]], 
#  height = get_wh(p, unit = "mm")[[2]],
#  units = "mm",
#)

```



# Figure 5 - fireseason


## A - Spatial pattern

关联封锁前两个月火点变化和上半年封锁时段内中位燃烧日期的变化, 在4°格网上使用t检验计算显著性.

```{r}
#| label: fig5_spatial


#-----------------------1: 4°格网上的空间变化格局
# 单个0.5°格网难以得到火季滞后的显著性水平.
# 如果我们聚合到4°的水平上, 大格网理论上就能有64个小格网, 就可以展示显著性水平.

##---------------1.1 提取0.5°格网所对应的4°编号
# global grid template with 0.5 degree
rast_tmpl_pt5 <- rast(
  nrows = 360, ncols = 720, nlyrs = 1,
  xmin = -180, xmax = 180, ymin = -90, ymax = 90,
  crs = "EPSG:4326"
)
# global grid template with 4 degree
rast_tmpl_4 <- rast(
  nrows = 45, ncols = 90, nlyrs = 1,
  xmin = -180, xmax = 180, ymin = -90, ymax = 90,
  crs = "EPSG:4326"
)
# 获得每个4°格网的编号
rast_cell_4 <- terra::init(rast_tmpl_4, fun = "cell")
rast_cell_4
# dimensions  : 45, 90, 1  (nrow, ncol, nlyr)
# resolution  : 4, 4  (x, y)
# extent      : -180, 180, -90, 90  (xmin, xmax, ymin, ymax)
# coord. ref. : lon/lat WGS 84 (EPSG:4326)

# 提取全球0.5°格网中心点的横纵坐标
grid_bridge <- data.table(
  id = values(terra::init(rast_tmpl_pt5, fun = "cell"))[, 1],
  x = values(terra::init(rast_tmpl_pt5, fun = "x"))[, 1],
  y = values(terra::init(rast_tmpl_pt5, fun = "y"))[, 1]
)
# 提取每个0.5°格网中心点所对应的4°格网编号
vec_ID4 <- terra::extract(
  x = rast_cell_4,
  y = grid_bridge[, .(x, y)],
  ID = FALSE
) %>%
  dplyr::pull(1)
grid_bridge[, ID4 := vec_ID4] %>%
  .[, c("x", "y") := NULL]
# "id" :  0.5°格网编号
# "ID4":  4°格网编号


##---------------1.2 计算0.5°格网上封锁前两个月的火点变化数目
# 封锁前两个月的火点数目差值
dt_diff_actfire <- panel_balance %>%
  .[break_group %in% c("unlock", "lock-mobility", "lock-policy", "lock-both")] %>%
  .[break_group != "unlock"] %>%
  .[week <= 26] %>%
  .[,
    year_group := cut(
      year, breaks = c(2016, 2019, 2020), include.lowest = TRUE,
      labels = c("fire_1619", "fire_2020")
    )
  ] %>%
  # the first two months since lockdown
  .[week_to_treated %in% 0:8,
    .(
      actfire_sum = sum(actfire_sum)
    ),
    by = c("id", "year_group", "year")
  ] %>%
  .[,
    .(
      actfire_sum = mean(actfire_sum)
    ),
    by = c("id", "year_group")
  ] %>%
  dcast(
    id ~ year_group,
    value.var = "actfire_sum"
  ) %>%
  .[,
    diff_actfire := fire_2020 - fire_1619
  ]


##---------------1.3 计算0.5°格网上的火季滞后周数
# 我们直接用2020年数值减去1619平均值, 这样对差值进行单样本t检验即可.
# 计算[起始封锁, 26周]中位燃烧日期的差值.
dt_diff_median <- panel_balance %>%
  .[break_group %in% c("unlock", "lock-mobility", "lock-policy", "lock-both")] %>%
  .[break_group != "unlock"] %>%
  .[order(id, year, week)] %>%
  .[,
    `:=`(
      moving_sum = stats::filter(
        actfire_sum, rep(1/3, 3), "convolution", sides = 2
      ) %>% as.numeric()
    ),
    by = "id"
  ] %>%
  .[is.na(moving_sum),
    moving_sum := actfire_sum
  ] %>%
  .[,
    year_group := cut(
      year, breaks = c(2016, 2019, 2020), include.lowest = TRUE,
      labels = c("median_1619", "median_2020")
    )
  ] %>%
  .[,
    .(
      moving_sum = mean(moving_sum)
    ),
    by = c("id", "year_group", "week", "cp_1")
  ] %>%
  .[order(id, year_group, week)] %>%
  # 我们的聚焦时段: [起始封锁周次, 26周]
  .[(week >= cp_1) & (week <= 26)] %>%
  # 对于格网, 在年份组内求累积和
  .[,
    cum_sum := base::cumsum(moving_sum),
    by = c("id", "year_group")
  ] %>%
  # 计算归一化后的累计频率
  .[,
    normfreq_sum := cum_sum / max(cum_sum),
    by = c("id", "year_group")
  ] %>%
  # 累积频率第一个大于0.5的周次即为中位燃烧日期
  .[normfreq_sum >= 0.5, .SD[1], by = c("id", "year_group")] %>%
  setnames(
    old = "week", new = "threweek_med"
  ) %>%
  .[, .(id, year_group, threweek_med)] %>%
  dcast(
    id ~ year_group,
    value.var = "threweek_med"
  ) %>%
  .[, diff_median := median_2020 - median_1619]

dt_diff_median[, sum(is.na(diff_median))] / nrow(dt_diff_median)
# 27%的格网在2020年没有观测到火点, 该怎么算提前还是滞后?
# 最简单的方案就是先搁置不管.


##---------------1.4 识别4°格网的显著性水平
# 使用t.test()需要两个及以上的观测.
# 在if(.N > 4)这一步, 如果我们设定成3及以下的数字, 始终会提醒我们:
# Error in t.test.default(nudgeweek_2) : data are essentially constant
# 也就是阈值周次一样, 无法使用t检验.
# 因此最后我们设定为大于4, 也就是需要每个4°大格网对应5个及以上的0.5°小格网.

dt_sig <- dt_diff_actfire %>%
  merge(
    dt_diff_median,
    by = "id",
    all = FALSE,
    sort = FALSE
  ) %>%
  # 剔除某个年份组内没有检测到火点的格网
  .[!is.na(diff_median)] %>%
  .[, .(id, diff_actfire, diff_median)] %>%
  # 0.5°格网与4°格网的对应关系
  merge(
    grid_bridge,
    by = "id",
    all = FALSE,
    sort = FALSE
  ) %>%
  .[order(ID4, id)] %>%
  .[,
    if(.N > 4) .(
      estimate_actfire = t.test(diff_actfire)[["estimate"]],
      p_actfire = t.test(diff_actfire)[["p.value"]],
      estimate_median = t.test(diff_median)[["estimate"]],
      p_median = t.test(diff_median)[["p.value"]]
    ),
    by = "ID4"
  ] %>%
  # 如果火点数值为常数(恒为0), 就会得不到p值.
  .[!is.na(p_actfire)] %>%
  .[!is.na(p_median)] %>%
  .[p_actfire >= 0.05, lab_actfire := "non"] %>%
  .[(estimate_actfire < 0)&(p_actfire < 0.05), lab_actfire := "neg"] %>%
  .[(estimate_actfire > 0)&(p_actfire < 0.05), lab_actfire := "pos"] %>%
  .[p_median >= 0.05,  lab_median := "non"] %>%
  .[(estimate_median < 0)&(p_median < 0.05), lab_median := "neg"] %>%
  .[(estimate_median > 0)&(p_median < 0.05), lab_median := "pos"] %>%
  .[, lab_combine := paste(lab_actfire, lab_median, sep = "-")] %>%
  merge(                                                # 获取4°格网的中心点坐标
    data.table(
      ID4 = values(terra::init(rast_tmpl_4, fun = "cell"))[, 1],
      x = values(terra::init(rast_tmpl_4, fun = "x"))[, 1],
      y = values(terra::init(rast_tmpl_4, fun = "y"))[, 1]
    ),
    by = "ID4",
    all = FALSE,
    sort = FALSE
  )

dt_sig[, summary(estimate_median)]
#     Min.  1st Qu.   Median     Mean  3rd Qu.     Max.
# -6.37500 -0.88699 -0.01667 -0.10027  0.70798  6.68750
dt_sig[, quantile(estimate_median, probs = seq(0, 1, 0.1))]
#    0%   10%   20%   30%   40%   50%   60%   70%   80%   90%  100% 
# -6.37 -2.09 -1.09 -0.66 -0.28 -0.01  0.23  0.53  0.94  1.56  6.68

dt_sig[, table(lab_actfire)]
# neg(179)  non(467)  pos(150)
# 41%格网的火点发生了显著变化
dt_sig[, table(lab_median)]
# neg(148)  non(538)  pos(110)
# 32%格网的火季发生了显著变化
dt_sig[, table(lab_combine)]
# neg-pos non-pos pos-pos
#      62      33      15
# neg-non non-non pos-non
#      98     361      79
# neg-neg non-neg pos-neg
#      19      73      56
# 封锁前期火点减少的话, 中位燃烧日期倾向于滞后
# 封锁前期火点增加的话, 中位燃烧日期倾向于提前



#-----------------------2: Plot
##---------------2.1 main plot
ggplot(dt_sig) +
  geom_sf(
    data = world_rel, fill = "white",
    color = "grey",  linewidth = 0.15
  ) +
  # linewidth must be wider so that to complete mask the previous land boundary
  geom_sf(
    data = world_boundary, fill = NA,
    color = "white", linewidth = 0.2
  )+
  # grids with insignificant coefficients
  geom_point(
    aes(
      x = x, y = y,
      size = pmin(abs(estimate_median), 2),
    ),
    data = dt_sig[lab_combine == "non-non"],
    shape = 21, color = "grey85", fill = "grey85", stroke = 0.2
  ) +
  # grids with significant coefficients
  geom_point(
    aes(
      x = x, y = y,
      fill = lab_combine,                                                # group
      size = pmin(abs(estimate_median), 2)
    ),
    data = dt_sig[lab_combine != "non-non"],
    shape = 21, color = "grey20", stroke = 0.2
  ) +
  scale_size(
    name = "Week deviation",
    range = c(0.4, 2),
    breaks = c(0.5, 1, 2),
    
    guide = guide_legend(
      override.aes = list(
        shape = 21, fill = NA,
        stroke = 0.2, color = "black"
      ),
      direction = "horizontal",
      theme = theme(
        legend.key = element_blank(),
        legend.background = element_blank(),
        legend.title.position = "left",
        legend.title = element_text(size = con_axis_title*.pt),
        legend.text = element_text(
          # narrow the distance between legend.key and legend.text
          margin = margin(l = 0, r = 0, unit = "mm"),
          size = con_axis_text*.pt
        ),
        legend.key.size = unit(4, "mm"),
        legend.key.spacing.x = unit(0.5, "mm")
      ),
      order = 0
    )
  ) +
  scale_fill_manual(
    values = c(
      "neg-pos" = "#4DAF4A",
      "non-pos" = "#A65628",
      "pos-pos" = "#FF7F00",
      
      "neg-non" = "#984EA3",
      "pos-non" = "#FFFF33",
      
      "neg-neg" = "#377EB8",
      "non-neg" = "#F781BF",
      "pos-neg" = "#E41A1C"
    ),
    
    guide = NULL
  ) +
  scale_x_continuous(
    expand = expansion(add = 0)
  ) +
  scale_y_continuous(
    limits = c(-57, 83),
    expand = expansion(add = 0)
  ) +
  theme(
    panel.background = element_rect(fill = "#C3E8F9"),    # "#C3E8F9", "#CCE7F9"
    panel.border = element_rect(fill = NA, color = "black", linewidth = 0.2),
    panel.grid = element_blank(),
    
    legend.position = "inside",
    legend.position.inside = c(0.35, 0),
    legend.justification.inside = c(0, 0),
    legend.box = "vertical",
    
    plot.title = element_text(size = con_axis_title*.pt, face = "bold"),
    plot.title.position = "plot",
    axis.text = element_text(size = con_axis_text*.pt)
  ) +
  labs(
    x = NULL,
    y = NULL,
    title = "A"
  )

#ggsave(
#  file.path(dir_figs, "fig5_a_main.pdf"),
#  width = 180, height = 80, units = "mm", dpi = 300
#)


##---------------2.2 legend
dt_legend <- data.table(
  x = rep(1:3, 3),
  y = rep(3:1, each = 3),
  lab_combine = c(
    "neg-pos", "non-pos", "pos-pos",
    "neg-non", "non-non", "pos-non",
    "neg-neg", "non-neg", "pos-neg"
  ),
  col = c(
    "#4DAF4A", "#A65628", "#FF7F00",
    "#984EA3",  "grey85", "#FFFF33",
    "#377EB8", "#F781BF", "#E41A1C"
  )
)

ggplot(dt_legend) +
  # grids with insignificant coefficients
  geom_point(
    aes(
      x = x, y = y
    ),
    data = dt_legend[lab_combine == "non-non"],
    size = 5,
    shape = 21, color = "grey85", fill = "grey85", stroke = 0.2
  ) +
  # grids with significant coefficients
  geom_point(
    aes(
      x = x, y = y,
      fill = col, color = col                                            # group
    ),
    data = dt_legend[lab_combine != "non-non"],
    size = 5,
    shape = 21, color = "grey20", stroke = 0.2
  ) +
  scale_fill_identity() +
  scale_color_identity() +
  scale_x_continuous(
    limits = c(0.5, 3.5),
    expand = expansion(add = 0),
    breaks = c(1, 2, 3),
    labels = c("a", "b", "c")
  ) +
  scale_y_continuous(
    limits = c(0.5, 3.5),
    expand = expansion(add = 0),
    breaks = c(1, 2, 3),
    labels = c("a", "b", "c")
  ) +
  theme(
    axis.ticks = element_blank(),
    
    panel.background = element_blank(),
    panel.grid = element_blank(),
    plot.background = element_blank(),
    plot.margin = margin(t = 0, r = 0, b = 0, l = 0, unit = "pt"),
    
    axis.text = element_blank(),
    axis.title = element_text(
      size = con_axis_title*.pt,
      margin = margin(t = 0, r = 0, b = 0, l = 0, unit = "pt")
    )
  ) +
  labs(
    x = "Count change",
    y = "Week deviation"
  )

#ggsave(
#  file.path(dir_figs, "fig5_a_legend.pdf"),
#  width = 25, height = 25, units = "mm"
#)


##---------------2.3 conditional fraction
dt_conditional <- dt_sig %>%
  .[,
    .(
      group_number = .N
    ),
    by = c("lab_combine", "lab_actfire", "lab_median")
  ] %>%
  .[,
    cd_fraction := group_number/sum(group_number)*100,
    by = "lab_actfire"
  ] %>%
  .[,
    lab_fraction := sprintf("%0.1f", cd_fraction)
  ] %>%
  .[order(lab_actfire, lab_median)]


dt_cd_plot <- dt_conditional %>%
  .[lab_actfire %in% c("neg", "pos")] %>%
  .[lab_median %in% c("neg", "pos")] %>%
  .[,
    x := c(1, 2, 3.5, 4.5)
  ]

ggplot(dt_cd_plot) +
  geom_col(
    aes(
      x = x, y = cd_fraction,
      fill = lab_combine
    ),
    width = 0.6,
    color = "grey20", linewidth = 0.2
  ) +
  geom_text(
    aes(
      x = x, y = cd_fraction + 1,
      label = lab_fraction
    ),
    vjust = "bottom",
    size = con_axis_text*0.7,
    size.unit = "mm"
  ) +
  scale_fill_manual(
    values = c(
      "neg-neg" = "#377EB8",
      "neg-pos" = "#4DAF4A",
      
      "pos-neg" = "#E41A1C",
      "pos-pos" = "#FF7F00"
    ),
    
    guide = NULL
  ) +
  annotate(
    "segment",
    x = c(0.5, 3),
    xend = c(2.5, 5),
    y = c(0, 0),
    yend = c(0, 0),
    linewidth = con_axis_line*0.5
  ) +
  annotate(
    "segment",
    x = 0.5, xend = 0.5,
    y = 0, yend = 40,
    linewidth = con_axis_line*0.5
  )+
  scale_x_continuous(
    limits = c(0.5, 5.5),
    expand = expansion(add = 0)
  ) +
  scale_y_continuous(
    limits = c(0, 43),
    expand = expansion(add = 0)
  ) +
  theme(
    panel.background = element_blank(),
    plot.background = element_blank(),
    panel.grid = element_blank(),
    axis.text = element_blank(),
    axis.ticks = element_blank(),
    
    axis.title = element_text(size = con_axis_title*.pt*0.7)
  ) +
  labs(
    x = "Decreased fire   Increased fire",
    y = "Conditional fraction (%)"
  )
  

ggsave(
  file.path(dir_figs, "fig5_a_minor.pdf"),
  width = 40, height = 25, units = "mm"
)

```


## B - China


```{r}
#| label: fig5_c

c("#984EA3", "#4DAF4A", "#377EB8", "#E41A1C")

#-----------------------1: 格网尺度移动平均
grid_moving <- panel_balance %>%
  copy() %>%
  .[,
    year_group := cut(
      year,
      breaks = c(2016, 2019, 2020),
      labels = c("2016-2019", "2020"),
      include.lowest = TRUE
    )
  ] %>%
  ## 计算3周移动平均值
  .[order(id, year, week)] %>%
  .[,
    `:=`(
      moving_sum = stats::filter(
        actfire_sum, rep(1/3, 3), "convolution", sides = 2
      ) %>% as.numeric()
    ),
    by = "id",
  ] %>%
  # 移动平均会在首尾项产生缺失值, 对于这些缺失值, 我们用原先的数值进行填充.
  .[is.na(moving_sum),
    moving_sum := actfire_sum
  ] %>%
  # 我们的聚焦时段: [0, 26周]
  .[week <= 26] %>%
  # 对各周在2016-2019年取平均值
  .[,
    .(
      moving_sum = mean(moving_sum)
    ),
    by = c("id", "year_group", "week", "CountryName", "CountryCode", "Region", "Subregion"),
  ]



#-----------------------2: 国家尺度数据框
# 查看封锁起始时间, 确认为第3周.
panel_unbalance[
  CountryName == "China",
  unique(cp_1)
]

panel_unbalance[
  CountryName == "China",
  .SD[1],
  by = "id"
] %>%
  .[, summary(cp_1)]
# 第3周开始封锁

# 移动平均
ts_China <- grid_moving %>%
  .[CountryName == "China"] %>%
  .[,
    .(
      ts_fire = sum(moving_sum)
    ),
    by = c("year_group", "week")
  ] %>%
  # 计算每周火点数目的频率占比
  .[,
    ts_freq := ts_fire/sum(ts_fire)*100,
    by = "year_group"
  ]

# 查看封锁后的累积频率分布
freq_China <- ts_China %>%
  .[week >= 3] %>%
  .[order(year_group, week)] %>%
  .[,
    cum_freq := cumsum(ts_fire)/sum(ts_fire),
    by = "year_group"
  ]
# 阈值     16-19年     2020年
#  0.5        13周       14周
#  0.9        20周       19周
# 0.95        23周       22周
# 也就是说如果我们用0.5作为阈值, 2020年火季滞后了, (符合直观认知).
# 但如果用0.9作为阈值, 反而会得到2020年火季提前的怪论.
# 所以我们还是要用0.5这一阈值.



#-----------------------3: 绘图
ggplot(ts_China) +
  # 每周观测值的柱状填充
  geom_col(
    aes(
      x = week, y = ts_freq,
      fill = year_group
    ),
    alpha = 0.2,
    position = position_identity()
  ) +
  # 每周观测值连线
  geom_line(
    aes(
     x = week, y = ts_freq,
     color = year_group
    ),
    alpha = 0.7, linetype = "dashed", linewidth = con_axis_line
  ) +
  scale_fill_manual(
    name = NULL,
    values = c(
      "2016-2019" = "#4DAF4A", "2020" = "#984EA3"
    )
  ) +
  scale_color_manual(
    name = NULL,
    values = c(
      "2016-2019" = "#4DAF4A", "2020" = "#984EA3"
    ),
    
    guide = guide_legend(
      override.aes = list(
        linetype  = "solid"
      )
    )
  ) +
  # 中位燃烧日期示例
  geom_vline(
    xintercept = 13, color = "#4DAF4A", linewidth = 0.8
  ) +
  geom_vline(
    xintercept = 15, color = "#984EA3", linewidth = 0.8
  ) +
  # 起始封锁周次
  annotate(
    "segment",
    x = 3, xend = 3,
    y = 0, yend = 1,
    color = "black", linewidth = con_axis_line
  ) +
  annotate(
    "segment",
    x = 13.1, xend = 14.9,
    y = 15.8, yend = 15.8,
    arrow = arrow(length = unit(1, "mm")),
    linewidth = con_axis_line
  ) +
  scale_y_continuous(
    breaks = c(0, 5, 10, 15),
    limits = c(0, 16.5),
    expand = expansion(mult = 0)
  ) +
  scale_x_continuous(
    breaks = c(1, 5, 10, 15, 20, 25),
    expand = expansion(add = 0.5)
  ) +
  theme(
    panel.background = element_rect(fill = "white"),
    panel.border = element_rect(
      fill = NA, color = "black", linewidth = con_axis_line*0.5
    ),
    
    legend.position = "inside",
    legend.position.inside = c(0, 1),
    legend.justification.inside = c(0, 1),
    legend.background = element_blank(),
    legend.key.size = unit(con_axis_text*1.5, "mm"),
    plot.title.position = "plot",
    
    legend.text = element_text(size = con_axis_text*.pt),
    axis.text = element_text(size = con_axis_text*.pt),
    axis.title = element_text(size = con_axis_text*.pt),
    plot.title = element_text(size = con_axis_title*.pt, face = "bold")
  ) +
  labs(
    x = "Weeks",
    y = "Share of observations (%)",
    title = "B"
  )

#ggsave(
#  file.path(dir_figs, "fig5_b.pdf"),
#  width = 90, height = 55, units = "mm"
#)
```


## C - Guatemala


```{r}
#| label: fig5_c

c("#984EA3", "#4DAF4A", "#377EB8", "#E41A1C")

#-----------------------1: 格网尺度移动平均
grid_moving <- panel_balance %>%
  copy() %>%
  .[,
    year_group := cut(
      year,
      breaks = c(2016, 2019, 2020),
      labels = c("2016-2019", "2020"),
      include.lowest = TRUE
    )
  ] %>%
  ## 计算3周移动平均值
  .[order(id, year, week)] %>%
  .[,
    `:=`(
      moving_sum = stats::filter(
        actfire_sum, rep(1/3, 3), "convolution", sides = 2
      ) %>% as.numeric()
    ),
    by = "id",
  ] %>%
  # 移动平均会在首尾项产生缺失值, 对于这些缺失值, 我们用原先的数值进行填充.
  .[is.na(moving_sum),
    moving_sum := actfire_sum
  ] %>%
  # 我们的聚焦时段: [0, 26周]
  .[week <= 26] %>%
  # 对各周在2016-2019年取平均值
  .[,
    .(
      moving_sum = mean(moving_sum)
    ),
    by = c("id", "year_group", "week", "CountryName", "CountryCode", "Region", "Subregion"),
  ]



#-----------------------2: 国家尺度数据框
# 查看封锁起始时间, 确认为第11周.
panel_unbalance[
  CountryName == "Guatemala",
  unique(cp_1)
]

panel_unbalance[
  CountryName == "Guatemala",
  .SD[1],
  by = "id"
] %>%
  .[, summary(cp_1)]
# 第11周开始封锁

# 移动平均
ts_Guatemala <- grid_moving %>%
  .[CountryName == "Guatemala"] %>%
  .[,
    .(
      ts_fire = sum(moving_sum)
    ),
    by = c("year_group", "week")
  ] %>%
  # 计算每周火点数目的频率占比
  .[,
    ts_freq := ts_fire/sum(ts_fire)*100,
    by = "year_group"
  ]

# 查看封锁后的累积频率分布
freq_Guatemala <- ts_Guatemala %>%
  .[week >= 11] %>%
  .[order(year_group, week)] %>%
  .[,
    cum_freq := cumsum(ts_fire)/sum(ts_fire),
    by = "year_group"
  ]
# 阈值     16-19年     2020年
#  0.5        17周       16周
#  0.9        21周       20周
# 0.95        22周       21周



#-----------------------3: 绘图
ggplot(ts_Guatemala) +
  # 每周观测值的柱状填充
  geom_col(
    aes(
      x = week, y = ts_freq,
      fill = year_group
    ),
    alpha = 0.2,
    position = position_identity()
  ) +
  # 每周观测值连线
  geom_line(
    aes(
     x = week, y = ts_freq,
     color = year_group
    ),
    alpha = 0.7, linetype = "dashed", linewidth = con_axis_line
  ) +
  scale_fill_manual(
    name = NULL,
    values = c(
      "2016-2019" = "#4DAF4A", "2020" = "#984EA3"
    )
  ) +
  scale_color_manual(
    name = NULL,
    values = c(
      "2016-2019" = "#4DAF4A", "2020" = "#984EA3"
    ),
    
    guide = guide_legend(
      override.aes = list(
        linetype  = "solid"
      )
    )
  ) +
  # 中位燃烧日期示例
  geom_vline(
    xintercept = 18, color = "#4DAF4A", linewidth = 0.8
  ) +
  geom_vline(
    xintercept = 16, color = "#984EA3", linewidth = 0.8
  ) +
  # 起始封锁周次
  annotate(
    "segment",
    x = 11, xend = 11,
    y = 0, yend = 1,
    color = "black", linewidth = con_axis_line
  ) +
  annotate(
    "segment",
    x = 17.9, xend = 16.1,
    y = 15.8, yend = 15.8,
    arrow = arrow(length = unit(1, "mm")),
    linewidth = con_axis_line
  ) +
  scale_y_continuous(
    breaks = c(0, 5, 10, 15),
    limits = c(0, 16.5),
    expand = expansion(mult = 0)
  ) +
  scale_x_continuous(
    breaks = c(1, 5, 10, 15, 20, 25),
    expand = expansion(add = 0.5)
  ) +
  theme(
    panel.background = element_rect(fill = "white"),
    panel.border = element_rect(
      fill = NA, color = "black", linewidth = con_axis_line*0.5
    ),
    
    legend.position = "inside",
    legend.position.inside = c(0, 1),
    legend.justification.inside = c(0, 1),
    legend.background = element_blank(),
    legend.key.size = unit(con_axis_text*1.5, "mm"),
    plot.title.position = "plot",
    
    legend.text = element_text(size = con_axis_text*.pt),
    axis.text = element_text(size = con_axis_text*.pt),
    axis.title = element_text(size = con_axis_text*.pt),
    plot.title = element_text(size = con_axis_title*.pt, face = "bold")
  ) +
  labs(
    x = "Weeks",
    y = "Share of observations (%)",
    title = "C"
  )

#ggsave(
#  file.path(dir_figs, "fig5_c.pdf"),
#  width = 90, height = 55, units = "mm"
#)
```


